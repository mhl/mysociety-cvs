#!/usr/bin/perl -w
#
# stats-report:
# Compile statistical reports on messages sent through FYR.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: stats-report,v 1.2 2005-10-25 18:53:15 chris Exp $';

use strict;
require 5.8.0;

# Horrible boilerplate to set up appropriate library paths.
use FindBin;
use lib "$FindBin::Bin/../perllib";
use lib "$FindBin::Bin/../../perllib";

use CGI;
use DateTime;
use DateTime::Format::Strptime;
use HTML::Entities;

use mySociety::Config;
BEGIN {
    mySociety::Config::set_file("$FindBin::Bin/../conf/general");
}
use mySociety::DBHandle qw(dbh);
use mySociety::DaDem;
use mySociety::MaPit;
use mySociety::VotingArea;

use FYR;

# add_report START END TITLE DESCRIPTION
# Add to the database a report on the period between the given START and END
# dates, with the given TITLE and DESCRIPTION, and return the ID of the new
# report.
sub add_report ($$$$) {
     my ($start, $end, $title, $description) = @_;
     my $id = dbh()->selectrow_array("select nextval('report_id_seq')");
     dbh()->do('
            insert into report (id, start, end, title, description)
            values (?, ?, ?, ?, ?)',
            {}, $id, $start->strftime('%Y-%m-%d'), $end->strftime('%Y-%m-%d'),
            $title, $description);
    return $id;
}

# add_section REPORT TITLE DESCRIPTION VARIABLE
# Add to the given REPORT a new section with the given TITLE and DESCRIPTION,
# to contain a table of values of the given VARIABLE, and return the ID of the
# new section.
sub add_section ($$$$) {
    my ($report, $title, $description, $variable) = @_;
    my $id = dbh()->selectrow_array("select nextval('section_id_seq')");
    dbh()->do('
            insert into section (id, report_id, title, description, variable)
            values (?, ?, ?, ?, ?)',
            {}, $id, $report, $title, $description, $variable);
    return $id;
}

# add_report_row SECTION FIELD VALUE ...
# Add a row to the given report SECTION. Permitted FIELDs are as follows, with
# obligatory fields marked *
# 
# * number_of_individuals
#       Number of people to whom this row applies.
#
#   representative_id
#   area_id
#       DaDem and MaPit IDs for a single representative or all representatives
#       sharing a common area.
#
# * representative_name
#       Name of a single representative or description of a class of
#       representatives.
#
# * area_name
#       Name of a single area or description of a set of areas.
#
#   representative_party
#       Name of party where representatives are from a common party.
#
#   representative_type
#       MaPit area type where representatives are elected on areas of a common
#       type.
#
# * value
#       Value of the variable.
#
#   min
#   max
#   stddev
#       Minimum, maximum and standard deviation of value which summarises a set
#       of values.
#
# Returns the row ID on success.
sub add_report_row ($%) {
    my ($section, %fields) = @_;
    my %permitted = map { $_ => 1 } qw(
            number_of_individuals representative_id area_id representative_name
            area_name representative_party representative_type value min max
            stddev
        );
    my @required = qw(
            number_of_individuals representative_name value
        );
    my @bad = grep { !exists($permitted{$_}) } keys %fields;
    die "bad fields in add_report_row: " . join(", ", @bad);
        if (@bad);
    my @missing = grep { !exists($fields{$_}) } @required;
    die "missing fields in add_report_row: " . join(", ", @missing);

    my $id = dbh()->selectrow_array("select nextval('report_row_id_seq')");
    $fields{id} = $id;
    $fields{section_id} = $section;
    my $s = 'insert into report_row ('
                . join(', ', sort keys %fields)
            . ' values ('
                . join(', ', map { '?' } keys %fields)
            . ')';
    dbh()->do($s, {}, map { $fields{$_} } sort keys %fields);
    return $id;
}

my $pp = new DateTime::Format::Strptime(
                pattern => '%Y-%m-%d',
                time_zone => 'Europe/London'
            );

my ($start, $end);
if (!GetOptions(
    "start=s"   => \$start,
    "end=s"     => \$end
    )) {
    print_log('err', "bad options; try --help for help");
    exit(1);
}

if (defined($end)) {
    my $e;
    if (!defined($e = $pp->parse_datetime($end))) {
        print_log('err', "end date should be an ISO date, not \"$end\"");
        exit(1);
    }
    $end = $e;
} else {
    $end = DateTime->today();
}

if (defined($start)) {
    my $s;
    if (!defined($s = $pp->parse_datetime($start))) {
        print_log('err', "start date should be an ISO date, not \"$start\"");
        exit(1);
    }
    $start = $s;
} else {
    $start = $end->clone()->subtract(-months => 6);
}

my $end = DateTime->now()->truncate(to => 'day');
my $start = $end->clone()->subtract(month => 6);

# Table of sections of reports which we produce. Each entry gives a title,
# description and generating function for that section. Sections are generated
# in the order stated.
my @report_sections = (
        [
            'Volume of messages',
            <<EOF,
Total number of messages submitted, sent, failed, and waiting to be sent,
during the stated period.
EOF
            \&message_volume
        ]
    );


sub find_periods ($) {
    my $list = shift;

    # Construct various time periods over which we produce reports.
    my $epoch = DateTime->from_epoch(epoch => 0, time_zone => 'Europe/London');
    my $now = DateTime->now(time_zone => 'Europe/London');
    my $today = $now->clone()->truncate(to => 'day');
    my $yesterday = $today->clone()->subtract(days => 1);
    my $thisweek = $today->clone()->truncate(to => 'week');
    my $lastweek = $thisweek->clone()->subtract(days => 7);
    my $thismonth = $today->clone()->truncate(to => 'month');
    my $lastmonth = $thismonth->clone()->subtract(months => 1);
    my $thisyear = $now->clone()->truncate(to => 'year');
    my $lastyear = $thisyear->clone()->subtract(years => 1);

    push(@$list, ['today',      $today,     $now]);
    push(@$list, ['yesterday',  $yesterday, $today]);
    push(@$list, ['this week',  $thisweek,  $now]);
    push(@$list, ['last week',  $lastweek,  $thisweek]);
    push(@$list, ['this month', $thismonth, $now]);
    push(@$list, ['last month', $lastmonth, $thismonth]);
    push(@$list, ['this year',  $thisyear,  $now]);
#    push(@$list, ['last year',  $lastyear,  $thisyear]);
    push(@$list, ['ever',       $epoch,     $now]);

    return $now;
}

my @timeperiods;
my $now = find_periods(\@timeperiods);

my $q = new CGI(""); # We're only using it for HTML generation.

print $q->start_html("WriteToThem usage report"),
        $q->h1("WriteToThem usage report"),
        $q->p('This report shows usage as of', $now->strftime('%H:%M:%S on %Y-%m-%d.'));

goto fish;

# Totals.
print
    $q->h2('All messages'),
    $q->start_table(),
        $q->Tr(
            $q->th([
                '',
                map { $_->[0] } @timeperiods
            ])
        ),
    # Written
        $q->Tr(
            $q->th('written'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # Sent
        $q->Tr(
            $q->th('(of which) sent'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and state in (
                                'bounce_wait',
                                'bounce_confirm',
                                'sent',
                                'finished'
                            )",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # Failed
        $q->Tr(
            $q->th('failed'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and state in (
                                'error',
                                'failed',
                                'failed_closed'
                            )",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # Not yet sent
        $q->Tr(
            $q->th('not yet sent'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and state in (
                                'new',
                                'pending',
                                'ready'
                            )",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    $q->end_table();

# Messages by type of representative.
print
    $q->h2('By type of representative'),
    $q->start_table(),
        $q->Tr(
            $q->th([
                '',
                map { $_->[0] } @timeperiods
            ])
        ),
    # MPs
        $q->Tr(
            $q->th('MPs'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and recipient_type = 'WMC'",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # MSPs
         $q->Tr(
            $q->th('MSPs'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and recipient_type in ('SPC', 'SPE')",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # Welsh Assembly
        $q->Tr(
            $q->th('Welsh AMs'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and recipient_type in ('WAC', 'WAE')",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # Greater London Assembly
        $q->Tr(
            $q->th('London AMs'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and recipient_type in ('LAC', 'LAE')",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # MEPs
        $q->Tr(
            $q->th('MEPs'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and recipient_type = 'EUR'",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    # all councillors
        $q->Tr(
            $q->th('all councillors'),
            $q->td([
                map {
                    scalar(dbh()->selectrow_array("
                        select count(id) from message
                        where created >= ? and created < ?
                            and recipient_type in (
                                'LBW', 'CED', 'DIS', 'UTW', 'UTE',
                                'MTW', 'COP', 'LGE'
                            )",
                        {}, $_->[1]->epoch(), $_->[2]->epoch()))
                } @timeperiods
            ])
        ),
    $q->end_table();

fish:

print
    $q->h2("Messages to MPs and their response rates"),
    $q->p("The table below records data from <em>questionnaire responses received during the given time period</em>. Questionnaire emails are sent two and three weeks after a message is dispatched. Because users may give a questionnaire response at any time after the questionnaire is sent, the column for \"total messages sent\" is approximate.");

# Need to obtain a list of MP/constituency names and then pick out messages
# by those.
print STDERR "get constituency IDs... ";
my $areaids = mySociety::MaPit::get_areas_by_type('WMC');
print STDERR "done\n";
print STDERR "get constituency info... ";
my %wmc = %{mySociety::MaPit::get_voting_areas_info($areaids)};
print STDERR "done\n";

print STDERR "get MP IDs... ";
my $repids = mySociety::DaDem::get_representatives([keys %wmc]);
print STDERR "done\n";

foreach (keys %$repids) {
    if (!@{$repids->{$_}}) {
        print STDERR "area #$_ ($wmc{$_}->{name}) has no representative\n";
    } else {
        my $repid = $repids->{$_}->[0];
        if ($repid !~ /^[1-9]\d*$/) {
            print STDERR "area #$_ ($wmc{$_}->{name}) has bad representative ID $repid\n";
        }
    }
}

print STDERR "get MP info... ";
my $reps = mySociety::DaDem::get_representatives_info([map { $_->[0] } grep { @$_ == 1 } values %$repids]);
print STDERR "done\n";
foreach my $areaid (keys %wmc) {
    if (@{$repids->{$areaid}}) {
        $wmc{$areaid}->{mp} = $reps->{$repids->{$areaid}->[0]};
        $wmc{$areaid}->{mp}->{id} = $repids->{$areaid}->[0];
    }
}

# Don't want to use v short time periods.
@timeperiods = (
        ['six months to date', DateTime->now()->subtract(months => 6), DateTime->now()],
        ['year to date',        DateTime->now()->subtract(years => 1), DateTime->now(, DateTime->now())]
    );

foreach (@timeperiods) {
    print STDERR "$_->[0] $_->[1] to $_->[2]\n";
}

print
    $q->start_table(),
    $q->Tr(
        $q->th(['', '', '']),
        map { $q->th({ -colspan => 4 }, $_->[0]) } @timeperiods
    ),
    $q->Tr(
        $q->th([
            'MP',
            'Party',
            'Constituency',
            (map {
                ('Total messages sent',
                'Questionnaire results',
                'Response received',
                'First time contacted')
            } @timeperiods)
        ])
    );

# List of references to hashes of constituency ID to results for each time
# period.
my @results = ( );

# Questionnaire answers: question_id #0 is "did you get a response?"; #1 is
# "is this your first time?".
my $stn = dbh()->prepare("
            select count(id), recipient_id
            from message
            where recipient_type = 'WMC'
                and state in ('sent', 'finished')
                and dispatched >= ? and dispatched < ?
                and dispatched < ?
            group by recipient_id");
my $stq = dbh()->prepare("
            select distinct on(message_id, question_id)
                message_id, question_id, answer, recipient_id
            from questionnaire_answer, message
            where questionnaire_answer.message_id = message.id
                and recipient_type = 'WMC'
                and dispatched >= ? and dispatched < ?
                and dispatched < ?");

foreach (@timeperiods) {
    my ($name, $st, $en) = @$_;
    print STDERR "get message counts for $name... ";
    # Total # messages
    my %r;
    $stn->execute($st->epoch(), $en->epoch(), time() - 86400 * 14);
    while (my ($n, $mp) = $stn->fetchrow_array()) {
        $r{$mp} = [$n, 0, 0, 0];
    }
    print STDERR "done\n";
    
    print STDERR "get questionnaire responses for $name... ";
    $stq->execute($st->epoch(), $en->epoch(), time() - 86400 * 14);
    my %mm;
    while (my ($msgid, $qid, $answer, $mp) = $stq->fetchrow_array()) {
        if (!exists($mm{$msgid})) {
            ++$r{$mp}->[1];
            $mm{$msgid} = 1;
        }
        if ($qid == 0 && $answer eq 'yes') {
            ++$r{$mp}->[2];
        } elsif ($qid == 1 && $answer eq 'yes') {
            ++$r{$mp}->[3];
        }
    }
    print STDERR "done\n";

    foreach my $area (values %wmc) {
        next unless ($area->{mp});
        $r{$area->{mp}->{id}} ||= [0, 0, 0, 0];
    }

    push(@results, \%r);
}

foreach my $areaid (sort { $wmc{$a}->{name} cmp $wmc{$b}->{name} } keys %wmc) {
    my $area = $wmc{$areaid};
    next unless (exists($area->{mp}));
    print $q->Tr($q->td([
            encode_entities($area->{mp}->{name}),
            encode_entities($area->{mp}->{party}),
            encode_entities($area->{name}),
            map {
                my $x = $results[$_]->{$area->{mp}->{id}};
                if ($x->[0] == 0) {
                    qw(- - - -)
                } else {
                    ($x->[0],
                    $x->[1] . sprintf("<br />%.1f%%", 100 * $x->[1] / $x->[0]),
                    $x->[2] . sprintf("<br />%.1f%%", 100 * $x->[2] / $x->[0]),
                    $x->[3] . sprintf("<br />%.1f%%", 100 * $x->[3] / $x->[0]))
                }
            } (0 .. $#results)
        ]));
}

print $q->end_table();

print $q->end_html();
