#!/usr/bin/perl -w
#
# pbsmsd:
# Pledgebank SMS daemon.
#
# This does two things: managing the sending of SMS messages from the outgoing
# message queue, and calling code to process messages which have been received.
#
# XXX a lot of this is boilerplate copied from fyrqd; we should probably try to
# modularise the common code.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: pbsmsd,v 1.8 2005-03-29 15:40:02 chris Exp $';

use strict;
require 5.8.0;

# Horrible boilerplate to set up appropriate library paths.
use FindBin;
use lib "$FindBin::Bin/../perllib";
use lib "$FindBin::Bin/../../perllib";

use Encode;
use Error qw(:try);
use Getopt::Long;
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Response;
use Pod::Usage;
use POSIX;
use Sys::Syslog;

use mySociety::Config;
BEGIN {
    mySociety::Config::set_file("$FindBin::Bin/../conf/general");
}
use mySociety::DBHandle qw(dbh);
use mySociety::PIDFile;
use mySociety::Util qw(print_log);

use PB;
use PB::SMS;

# Variable set in signal handler to indicate termination.
my $foad = 0;

# run_sending_process
# Process the SMS sending queue.
sub run_sending_process () {
    # We attempt to send messages for which there have been no previous sending
    # attempts; or, if a previous attempt has failed, on an exponential backoff
    # schedule. With the default one-minute interval and maximum of ten
    # attempts the last delivery attempt will occur about four hours after the
    # first delivery attempt.
    use constant send_max_attempts => 10;
    use constant send_retry_interval => 60;
    my $s = dbh()->prepare("
                    select id from outgoingsms
                    where lastsendattempt is null
                        or (lastsendstatus <> 'success'
                            and lastsendattempt < ? - ? * (2 ^ (numsendattempts - 1))
                            and numsendattempts < ?)
                    order by random()
                ");

    my $ua = new LWP::UserAgent(
                    agent => "PledgeBank pbsmsd $rcsid",
                );

    my $niter = 0;
    while (!$foad && $niter < 10000) {
        $s->execute(time(), send_retry_interval, send_max_attempts);
        while (my $id = $s->fetchrow_array()) {
            # Grab a lock on the message, assuming that it still needs to be sent.
            my ($recipient, $message, $ispremium, $numattempts) =
                dbh()->selectrow_array("
                    select recipient, message, ispremium, numsendattempts
                    from outgoingsms
                    where lastsendattempt is null
                        or (lastsendstatus <> 'success'
                            and lastsendattempt < ? - ? * (2 ^ (numsendattempts - 1)))
                    for update", {}, time(), send_retry_interval);
            next if (!defined($recipient));
            if ($numattempts >= send_max_attempts) {
                # Give up.
                my $howlong = time() - dbh()->selectrow_array('select whensubmitted from outgoingsms where id = ?', {}, $id);
                my @t = ();
                foreach ([86400, 'd'], [3600, 'h'], [60, 'm'], [1, 's']) {
                    if ($howlong > $_->[0]) {
                        push(@t, int($howlong / $_->[0]) . " " . $_->[1]);
                        $howlong = $howlong % $_->[0];
                    }
                }
                print_log('info', "giving up on delivery of #$id after " . join(' ', @t));
                dbh()->do('delete from outgoingsms where id = ?', {}, $id);
            } else {
                # Assemble parameters for message.
                #
                #   strMethod               sendSMS
                #   strShortcode            sending short code
                #   strMobile               recipient
                #   strMessage              IA5 octets of message
                #   intTransactionID        our reference
                #   intPremium              cost of premium SMS
                #
                $recipient =~ s/^\+//;
                my %p = (
                        strMethod => 'sendSMS',
                        strShortcode => '60022',        # XXX
                        strMobile => $recipient,
                        intTransactionID => $id,
                        intPremium => ($ispremium ? 25 : 0)     # XXX
                    );

                # Now we need to send the message. That means trying to
                # encode it in IA5.
                eval {
                    $p{strMessage} = PB::SMS::encode_ia5($message);
                };
                if ($@) {
                    print_log('err', "outgoing #$id, '$message', cannot be expressed in IA5; abandoning message");
                    dbh()->do('delete from outgoingsms where id = ?', {}, $id);
                } else {
                    # We're OK to attempt sending.
                    my ($status, $extra);
                    eval {
                        local $SIG{ALRM} = sub { die "timed out in eval\n"; };
                        alarm(300);
                        print_log('debug', "outgoing #$id: attempting to send by HTTP POST");
                        my $resp = $ua->post('http://www.c360uk.com/api/complex/pledge-query.php', \%p);
                        alarm(0);
                        if (!defined($resp)) {
                            $! ||= '(no error)';
                            print_log('warning', "outgoing #$id: no response from user-agent; system error: $!");
                            ($status, $extra) = ('systemerror', $!);
                        } elsif ($resp->code() != 200) {
                            print_log('warning', "outgoing #$id: failure to send; HTTP status: " . $resp->status_line());
                            foreach (split(/\r?\n/, $resp->content())) {
                                print_log('warning', "outgoing #$id: remote error: $_");
                            }
                            ($status, $extra) = ('httperror', $resp->status_line());
                        } else {
                            print_log('info', "outgoing #$id: sent");

                            my $result = $resp->content();
                            if ($result =~ /^ID=(\d+)/) {
                                # Success; ID returned.
                                print_log('debug', "outgoing #$id: foreign ID is $1");
                                dbh()->do('update outgoingsms set foreignid = ? where id = ?', {}, $1, $id);
                                ($status, $extra) = ('success', undef);
                            } else {
                                $result =~ s/\s*$//;
                                $result = 'Miscellaneous error (blank ID)'
                                    if ($result =~ /^ID=$/);
                                print_log('warning', "outgoing #$id: remote error: $result");
                                ($status, $extra) = ('remoteerror', $result);
                            }
                        }
                    };
                    if ($@) {
                        ($status, $extra) = ('systemerror', $@);
                    }
                    dbh()->do('
                            update outgoingsms
                            set lastsendattempt = ?,
                                lastsendstatus = ?,
                                lastsendextrastatus = ?,
                                numsendattempts = numsendattempts + 1
                            where id = ?', {}, time(), $status, $extra, $id);
                }
            }
            dbh()->commit();
        }

        # Pause for a bit.
        # XXX could probably be a bit more intelligent than this! In particular
        # (a) under heavy traffic we shouldn't wait at all; (b) under very
        # light traffic we should probably wait for longer; (c) if we seem to
        # be suffering some kind of connectivity or other failure (e.g. all
        # message sending attempts fail) we should hold off for quite a while.
        sleep(10);

        ++$niter;
    }

    print_log('info', "sending process shutting down after $niter iterations");
}

# run_processing_process
# Process any received messages.
sub run_processing_process () {
    # We process sent and received messages alternately. The limit clauses are
    # there so that in the presence of heavy traffic we maintain acceptable
    # latency in processing messages in both directions.
    my $s_sent = dbh()->prepare("
                        select id, message, '60022', recipient, status
                            from outgoingsms
                        where status = 'delivered'
                            or status = 'failed'
                            or status = 'rejected'
                        order by random()
                        limit 20");
    my $s_received = dbh()->prepare("
                        select id, message, sender, recipient, null
                            from incomingsms
                        order by random()
                        limit 20");

    my $niter = 0;
    while (!$foad && $niter < 10000) {
        my $n;
        my $delay = 10;
        foreach my $s ($s_sent, $s_received) {
            $s->execute();
            $n = 0;
            while (my ($id, $message, $sender, $recipient, $status) = $s->fetchrow_array()) {
                my $H;
                if (!defined($status)) {
                    $H = \@PB::SMS::received_handlers;
                } elsif ($status eq 'delivered') {
                    $H = \@PB::SMS::delivered_handlers;
                } else {
                    $H = \@PB::SMS::failed_handlers;
                }
                my $result;
                my $dodelete = 1;
                foreach (@$H) {
                    my ($name, $func) = @$_;
                    eval {
                        if (defined($status)) {
                            print_log('debug', "processing outgoing #$id (status $status) with $name");
                            $result = &$func($id, $message, $sender, $recipient, $status);
                            print_log('debug', "result of $name is " . (defined($result) ? $result : '(undef)'));
                        } else {
                            print_log('debug', "processing incoming #$id with $name");
                            $result = &$func($id, $message, $sender, $recipient);
                            print_log('debug', "result of $name is " . (defined($result) ? $result : '(undef)'));
                        }
                    };
                    if ($@) {
                        if (defined($status)) {
                            print_log('warning', "while processing outgoing #$id (status $status) with $name: $@");
                        } else {
                            print_log('warning', "while processing incoming #$id with $name: $@");
                        }
                        $dodelete = 0;
                        last;
                    } elsif ($result == 1) {
                        last;
                    }
                }
                if ($dodelete) {
                    # Processing is complete, so delete this SMS and commit the
                    # transaction.
                    if (defined($status)) {
                        dbh()->do('delete from outgoingsms where id = ?', {}, $id);
                    } else {
                        dbh()->do('delete from incomingsms where id = ?', {}, $id);
                    }
                    dbh()->commit();
                } else {
                    # Something went wrong; for safety, roll back.
                    dbh()->rollback();
                }
                ++$n;
            }
            $delay = 0 if ($n == 20);
        }

        sleep($delay) if ($delay);
        ++$niter;
    }

    print_log('info', "processing process shutting down after $niter iterations");
}

# Entry point.
my $numprocesses = mySociety::Config::get('SMS_DAEMON_SEND_PROCESSES', 5);
my $pidfilepath = mySociety::Config::get('SMS_DAEMON_PIDFILE', '/var/run/pbsmsd.pid');
my $nodetach = 0;
my $help = 0;
if (!GetOptions(
        'senderprocesses=i' =>  \$numprocesses,
        'pidfile=s' =>          \$pidfilepath,
        'debug' =>              \$nodetach,
        'help' =>               \$help
    )) {
    print_log('err', "bad options; try --help for help");
    exit(1);
}

if ($help) {
    pod2usage(-exitval => 0, -verbose => 1);
    exit(0);
}

$numprocesses = 2 if ($numprocesses < 1 or $numprocesses > 100);

mySociety::Util::daemon() unless ($nodetach);

my $pidfile;
try {
    $pidfile = new mySociety::PIDFile($pidfilepath);
} catch mySociety::PIDFile::Error with {
    my $E = shift;
    print_log('err', $E->text());
    exit(1);
};

print_log('info', "starting up; 1 processing process, $numprocesses sender processes");

# Main loop.
$SIG{TERM} = $SIG{INT} = sub { $foad = POSIX::SIGTERM }; # so children know to exit
    # catch SIGINT so that we can conveniently be run from the terminal with
    # --debug, and still shut down cleanly.
my $termsig = mySociety::Util::manage_child_processes({
        processing =>   [1, \&run_processing_process],
        sending =>      [$numprocesses, \&run_sending_process]
    });

undef($pidfile);

if ($termsig == SIGHUP) {
    print_log('notice', "restarting on signal $termsig");
    { exec($FindBin::Script, @ARGV); }
    print_log('err', "exec: $!");
    exit(1);
} else {
    print_log('notice', "shutting down on signal $termsig");
}

exit(0);

__END__

=head1 NAME

pbsmsd

=head1 SYNOPSIS

pbsmsd --help | [OPTIONS]

=head1 DESCRIPTION

SMS sending/received-message processing daemon for PledgeBank.

=head1 OPTIONS

=over 4

=item --help

Display information about using the program.

=item --debug

Don't detach from controlling terminal; log diagnostics to standard error as
well as the system log.

=item --pidfile PATH

Use PATH as the location of the PID file. By default, uses the value defined in
the config file, or "/var/run/pbsmsd.pid".

=item --processes NUM

Run NUM SMS sending child processes. By default, uses the value defined in the
config file, or 2. There is always only one received-message processing
process.

=back

=head1 COPYRIGHT 

Copyright (c) 2005 UK Citizens Online Democracy

=head1 VERSION

$Id: pbsmsd,v 1.8 2005-03-29 15:40:02 chris Exp $

