#!/usr/local/bin/php -q
<?php
/* 
 * frequentupdate:
 * Run from cron regularly to detect pledges which have succeeded/failed and
 * so forth, and take appropriate action.
 *
 * Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
 * Email: matthew@mysociety.org. WWW: http://www.mysociety.org/
 *
 * $Id: frequentupdate,v 1.32 2005-06-14 15:23:37 francis Exp $
 *
 */

require_once "../conf/general";
require_once '../phplib/db.php';
require_once '../phplib/fns.php';
require_once "../phplib/auth.php";
require_once "../phplib/person.php";
require_once '../../phplib/utility.php';

function verbose($str) {
    global $verbose;
    if ($verbose) 
        fwrite(STDERR, "frequentupdate: $str\n");
}
function error($str) {
    fwrite(STDERR, "frequentupdate: ERROR: $str\n");
}

$short_opts = '';
$long_opts = array('verbose','testrun','help');
require_once 'phpcgi';

$switches = $options[0];
$args = $options[1];
$verbose = 0; 
foreach ($switches as $switch) {
    if ($switch[0]=='--verbose') $verbose = 1;
    if ($switch[0]=='--help') {
?>

PledgeBank frequent update script. This is responsible for completing
pledges, generating automatic messages, and so forth. It should be run
periodically from cron.

Usage: frequentupdate [--verbose]

--help      Display this help message
--verbose   Display more information

<?
        exit;
    }
}

db_connect();

mark_pledges_successful();
send_automatic_failure_messages();
send_pending_messages();

/* mark_pledges_successful
 * Mark pledges which have exceeded their target as successful, and dispatch
 * automatic success messages. */
function mark_pledges_successful() {
    verbose("finding newly successful pledges");
    $q = db_query('
            select * from pledges
            where confirmed
                and whensucceeded is null
                and pb_current_timestamp() < date
                and (select count(id) from signers
                    where pledge_id = pledges.id) >= target
            for update');

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) has succeeded");
    
        db_query('
                update pledges
                set whensucceeded = pb_current_timestamp()
                where id = ?', $pledge['id']);
        
        /* Set up messages to go to creator and signers. */
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-creator',
                    true, false, false,
                    'succeeded-creator'
                )", $pledge['id']);

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-signers',
                    false, true, false,
                    'succeeded-signer'
                )", $pledge['id']);
    }

    db_commit();
    verbose("finished newly successful pledges");
}

/* send_fallback_announcement_messages
 * Send automatic post-success SMS messages for pledges for which no
 * announcement has been generated by the sender after one week. */
function send_fallback_announcement_messages() {
    verbose("finding pledges with no announcement messages");
    $q = db_query("
                select * from pledges
                where confirmed
                    and whensucceeded is not null
                    and whensucceeded < pb_current_timestamp - '1 week'::interval
                    and (select id
                        from message
                        where pledge_id = pledges.id
                        and circumstance = 'success-announce'
                        or circumstance = 'success-fallback-announce') is null
                for update");
}

/* send_automatic_failure_messages
 * Send automatic pledge failure messages for pledges which have failed
 * (passed their deadline without the number of signers reaching the
 * threshold) and for which no such message has previously been sent. */
function send_automatic_failure_messages() {
    verbose("finding newly failed pledges");
    $q = db_query("
                select * from pledges
                where confirmed
                    and whensucceeded is null
                    and pb_current_date() > date
                    and (select id
                        from message
                        where pledge_id = pledges.id
                        and circumstance = 'failure-auto-creator') is null
                for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) has failed");

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'failure-auto-creator',
                    true, false, false,
                    'failed-creator'
                )", $pledge['id']);


        /* Unlike automatic success messages, automatic failure messages go
         * by SMS too, because there's no other way for SMS signers to hear
         * about them. */
        $sms = "PledgeBank here. Sorry, the ${pledge['ref']} pledge has failed. Better luck next time!";

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename, sms
                ) values (
                    ?, 'failure-auto-signers',
                    false, true, false,
                    'failed-signer', ?
                )", array($pledge['id'], $sms));
    }
    
    db_commit();

    verbose("finished newly failed pledges");
}

/* send_pending_messages
 * Dispatch messages to pledge signers and creators which have not yet been
 * sent. */
function send_pending_messages() {
    /* Messages to creators. */
    verbose("sending pending creator messages");
    
    $q = db_query('
                select * from message
                where sendtocreator
                    and (select message_id
                        from message_creator_recipient
                        where message_id = id
                            and message_creator_recipient.pledge_id
                                = message.pledge_id) is null
                order by random()');

    while ($msg = db_fetch_array($q)) {
        /* Grab lock. As ever, this is bloody ugly, because we have to do
         * something (send an email) which isn't transactional in the
         * database, so we must do only one thing per transaction and commit
         * once that transaction has succeeded. */
        $f = db_getOne('
                    select message_id
                    from message_creator_recipient
                    where message_id = ?
                    for update', $msg['id']);

        if (!is_null($f)) {
            verbose("message #${msg['id']} sent while waiting for lock; skipping");
            continue;
        }
    
        $pledge = new Pledge(intval($msg['pledge_id']));
        $data = $pledge->data;
        verbose("message #${msg['id']} is for pledge #".$pledge->id()." (".$pledge->ref()."); circumstance '${msg['circumstance']}'");

        /* XXX we also need a URL containing a token which is sent on
         * success to the signer. For now just generate this here, but
         * later on we'll need to move it into message, so that we can send
         * reminders. */
        if ($msg['circumstance'] == 'success-auto-creator' or
            $msg['circumstance'] == 'failure-auto-creator' or
            $msg['circumstance'] == 'announce-post') {
            $url = person_make_signon_url(array(
                    "reason_web" => "Before you can send a message to all the signers, we need to check that you created the pledge.",
                    "reason_email" => "Then you will be able to send a message to everyone who has signed your pledge.",
                    "reason_email_subject" => "Send a message to your pledge signers at PledgeBank.com"),

                $pledge->creator_email(), "GET", $pledge->url_announce(), array());
            $data['url'] = $url;
        }

        // Make any extra headers
        $headers = array();

        // Send with template or raw appropriately
        $f = false;
        if (isset($msg['emailtemplatename'])) {
            verbose("sending message #${msg['id']} using email template '${msg['emailtemplatename']}'");
            $f = pb_send_email_template($pledge->creator_email(), $msg['emailtemplatename'], $data, $headers);
        } else {
            verbose("sending message #${msg['id']} as raw email, subject '${msg['emailsubject']}'");
            $f = pb_send_email($pledge->creator_email(), $msg['emailsubject'], $msg['emailbody'], $headers);
        }

        // Store success
        if ($f)
            db_query('
                    insert into message_creator_recipient
                        (message_id, pledge_id)
                    values (?, ?)', array($msg['id'], $pledge->id()));
        else
            error("failed to send message #${msg['id']} to creator of pledge #${pledge['id']} (${pledge['ref']})");

        db_commit();
    }

    /* Messages to signers. Slightly nastier because of the
     * signed-after-success and SMS options. We grab message and recipient
     * info for each signer-message pair which is pending on delivery. */
    verbose("sending pending signer messages");
     
    $q = db_query('
                select message.*,
                    signers.id as signer_id,
                    signers.name as signer_name,
                    signer_person.email as signer_email,
                    signers.mobile as signer_mobile,
                    extract(epoch from signers.signtime)
                        - extract(epoch from message.whencreated) as howlongago
                from message, pledges, signers
                left join person as signer_person on signer_person.id = signers.person_id
                where sendtosigners
                    and message.pledge_id = signers.pledge_id
                    and message.pledge_id = pledges.id
                    and (message.sms is not null or signers.person_id is not null)
                    and (pledges.whensucceeded is null or sendtolatesigners
                            or signers.signtime < pledges.whensucceeded)
                    and (select signer_id
                        from message_signer_recipient
                        where message_id = message.id
                            and signer_id = signers.id) is null
                order by random()');
        /* XXX ugly. For a raw email we will transmit the (possibly large)
         * body of the mail over the wire once for each row. Should do a
         * subquery for it and cache the result. */
    
    while ($r = db_fetch_array($q)) {
        /* Grab a lock. Actually it doesn't matter what we lock here, so just
         * use the row in the signers table. */
        db_getOne('select id from signers where id = ? for update', $r['id']);

        /* Check that the message hasn't already been sent. */
        $f = db_getOne('
                    select message_id
                    from message_signer_recipient
                    where message_id = ? and signer_id = ?',
                    array($r['id'], $r['signer_id']));

        if (!is_null($f)) {
            verbose("message #${r['id']} sent to signer #${r['signer_id']} while waiting for lock; skipping");
            continue;
        }

        verbose("message #${r['id']} to be sent to signer #${r['signer_id']}");

        // Make any extra headers
        $pledge = db_getRow('select pledges.*, person.email as email 
            from pledges left join person on person.id = pledges.person_id
            where pledges.id = ?', $r['pledge_id']);

        $headers = array();
        if ($r['fromaddress'] == 'pledgebank') {
            // the default in pb_send_email_internal is from PledgeBank
        } elseif ($r['fromaddress'] == 'creator') {
            $headers['From'] = $pledge['name'] . " <" . $pledge['email'] .">";
        } else {
            error("Unknown 'from' in message " . $r['id'] . ": " . $msg['fromaddress']);
        }

        if (is_null($r['signer_email'])) {
            /* Send by SMS. */
            verbose("delivering message #${r['id']} by SMS to signer #${r['signer_id']} on ${r['signer_mobile']}");
            db_query('
                    insert into outgoingsms (recipient, message, whensubmitted)
                    values (?, ?, ?)',
                    array($r['signer_mobile'], $r['sms'], time()));
            $f = true;
        } elseif (isset($r['emailtemplatename'])) {
            /* Send email template. */
            verbose("sending message #${r['id']} using email template '${r['emailtemplatename']}'");
            $f = pb_send_email_template($r['signer_email'], $r['emailtemplatename'], $pledge, $headers);
        } else {
            /* Send raw mail. */
            verbose("sending message #${r['id']} as raw email, subject '${r['emailsubject']}'");
            $emailbody = $r['emailbody'];

            /* If this is being sent to a late signer, we might want to remark
             * on that. */
            if (!is_null($emailbody) && $r['howlongago'] > 3600) {
                if ($r['howlongago'] > 2 * 86400)
                    $h = sprintf('%d days ago', intval($r['howlongago'] / 86400));
                elseif ($r['howlongago'] > 7200)
                    $h = sprintf('%d hours ago', intval($r['howlongago'] / 3600));
                else
                    $h = 'one hour ago';

                $emailbody = "[ You signed this pledge after this message was sent to the other signers. They will have received copies $h. ]\n\n" . $emailbody;
            }
            
            $f = pb_send_email($r['signer_email'], $r['emailsubject'], $emailbody, $headers);
        }

        if ($f)
            db_query('
                insert into message_signer_recipient (message_id, signer_id)
                values (?, ?)', array($r['id'], $r['signer_id']));
        else
            error("failed to send message #${r['id']} to signer #${r['signer_id']} of pledge #${r['pledge_id']}");


        db_commit();
    }
}
