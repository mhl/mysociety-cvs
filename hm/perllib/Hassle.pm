#!/usr/bin/perl
#
# Hassle.pm:
# Common code for hassleme.
#
# Copyright (c) 2005 Chris Lightfoot. All rights reserved.
# Email: chris@ex-parrot.com; WWW: http://www.ex-parrot.com/~chris/
#
# $Id: Hassle.pm,v 1.4 2009-04-22 16:28:18 louise Exp $
#

package Hassle;

use DBI;
use DBD::Pg;
use Digest::SHA1 qw(sha1_hex);
use IO::Pipe;
use MIME::QuotedPrint;
use POSIX qw();

use mySociety::Config;

BEGIN {
    use Exporter ();
    @Hassle::ISA = qw(Exporter);
    @Hassle::EXPORT = qw(&dbh &secret &sendmail &token &check_token &is_valid_email);
}
#our @EXPORT_OK;

sub dbh () {
    our $dbh;
    if (!$dbh) {
        $dbh ||= DBI->connect(
                        "dbi:Pg:dbname=" . mySociety::Config::get('HM_DB_NAME')
                        . ";host=" . mySociety::Config::get('HM_DB_HOST')
                        . ";port=" . mySociety::Config::get('HM_DB_PORT')
                        . ";sslmode=allow",
                        mySociety::Config::get('HM_DB_USER'),
                        mySociety::Config::get('HM_DB_PASS'),
                        {
                            AutoCommit => 0,
                            PrintError => 0,
                            RaiseError => 1,
                            PrintWarn => 0
                        });
        my $s = $dbh->selectrow_array('select secret from secret');
        if (!defined($s)) {
            $dbh->{RaiseError} = 0;
            $dbh->do('insert into secret (secret) values (?)', {},
                        sprintf('%08x%08x', int(rand(0xffffffff)),
                                            int(rand(0xffffffff))));
            $dbh->commit();
            $dbh->{RaiseError} = 1;
        }
    }
    return $dbh;
}

sub secret () {
    return scalar(dbh()->selectrow_array('select secret from secret'));
}

=item sendmail RECIPIENT SUBJECT TEXT

Send an email to RECIPIENT with the given SUBJECT and TEXT. Subject and body
should be UTF-8 strings.

=cut
sub sendmail ($$$) {
    my ($to, $subject, $text) = @_;

    # Add a signature to the body.
    $weburl = mySociety::Config::get('WEBURL');
    $text .= <<EOF;
-- 
$weburl/
EOF

    # Quoted-printable encoding of the subject.
    if ($subject =~ /[\x00-\x1f\x80-\xff]/) {
        $subject =~ s/([\x00-\x20\x80-\xff])/sprintf('=%02x', ord($1))/ge;
        $subject = "=?UTF-8?Q?$subject?=";
    }

    # Generate a message-ID.
    my $msgid = sprintf('<%08x%0xf@hassleme.co.uk>',
                        int(rand(0xffffffff)), int(rand(0xffffffff)));

    my $p = new IO::Pipe() || die "pipe: $!";
    die "fork: $!" if (!defined(my $pid = fork()));
    if ($pid == 0) {
        $p->reader();
        POSIX::close(0);
        POSIX::dup($p->fileno());
        { exec(mySociety::Config::get('SENDMAIL'), $to); }
        die mySociety::Config::get('SENDMAIL') . ": exec: $!";
    }
    
    $p->writer();
    $p->print(<<EOF,
From: Hasslebot <hassle\@hassleme.co.uk>
To: $to
Subject: $subject
Message-ID: $msgid
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable

EOF
            MIME::QuotedPrint::encode_qp($text)
        ) || die "write to sendmail: $!";
    $p->close();

    wait();
    if ($? != 0) {
        die "sendmail: \$? = $?";
    }
}

=item token ID

Return a signed token for ID.

=cut
sub token ($) {
    my $i = shift;
    my $salt = int(rand(10000));
    $tok = "${i}X${salt}X" . substr(sha1_hex(secret() . ",$i,$salt"), 0, 12);
    return $tok;
}

=item check_token TOKEN

If TOKEN is a valid token generated by token, return the ID it encodes.

=cut
sub check_token ($) {
    my $token = shift;
    return undef if (!$token);
    my ($i, $salt, $hash) = split(/[,X]/, $token);
    return undef if ($hash ne substr(sha1_hex(secret() . ",$i,$salt"), 0, 12));
    return $i;
}

=item delete_recipient EMAIL

Mark any recipient records relating to EMAIL address as deleted

=cut
sub delete_recipient ($){
    my $email = shift;
    return undef if (!$email);
    dbh()->do('update recipient set deleted=true where email = ?',
                {}, $email);
    dbh()->commit();
}

=item is_valid_email EMAIL

If EMAIL is a valid address, return undef; otherwise return a sentence
explaining what's wrong with it.

=cut
sub is_valid_email ($) {
    my $addr = shift;
    our $is_valid_address_re;

    # This is derived from the grammar in RFC2822.
    if (!defined($is_valid_address_re)) {
        # mailbox = local-part "@" domain
        # local-part = dot-string | quoted-string
        # dot-string = atom ("." atom)*
        # atom = atext+
        # atext = any character other than space, specials or controls
        # quoted-string = '"' (qtext|quoted-pair)* '"'
        # qtext = any character other than '"', '\', or CR
        # quoted-pair = "\" any character
        # domain = sub-domain ("." sub-domain)* | address-literal
        # sub-domain = [A-Za-z0-9][A-Za-z0-9-]*
        # XXX ignore address-literal because nobody uses those...

        my $specials = '()<>@,;:\\\\".\\[\\]';
        my $controls = '\\000-\\037\\177';
        my $highbit = '\\200-\\377';
        my $atext = "[^$specials $controls$highbit]";
        my $atom = "$atext+";
        my $dot_string = "$atom(\\s*\\.\\s*$atom)*";
        my $qtext = "[^\"\\\\\\r\\n$highbit]";
        my $quoted_pair = '\\.';
        my $quoted_string = "\"($qtext|$quoted_pair)*\"";
        my $local_part = "($dot_string|$quoted_string)";
        my $sub_domain = '[A-Za-z0-9][A-Za-z0-9-]*';
        my $domain = "$sub_domain(\\s*\\.\\s*$sub_domain)*";

        $is_valid_address_re = "^$local_part\\s*@\\s*$domain\$";
    }

    if ($addr =~ m#$is_valid_address_re#) {
        my ($domain) = ($addr =~ /@(.+)/);
        our $R;
        if (!$R) {
            $R = new Net::DNS::Resolver();
            $R->tcp_timeout(3); # small timeout since this blocks FCGI server
#            $R->udp_timeout(3);
                # XXX old Net::DNS::Resolver on sphinx is TCP only?
        }
        my $resp = $R->send($domain, qw(IN MX A));
        if (!defined($resp)     # timeout, probably
            || $resp->header()->ancount() > 0) {
            return undef;
        } else {
            # Definite negative response.
            return "The domain '$domain' doesn't seem to exist, so we wouldn't be able to send email to '$addr'";
        }
    } else {
        return "The email address '$addr' doesn't seem to be valid (its format is wrong)";
    }
}


1;
