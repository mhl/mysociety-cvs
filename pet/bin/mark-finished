#!/usr/bin/php -q
<?php
/* 
 * mark-finished:
 * Run from cron daily to detect petitions which have finished
 *
 * Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
 * Email: matthew@mysociety.org. WWW: http://www.mysociety.org/
 *
 * $Id: mark-finished,v 1.10 2008-01-16 19:30:17 matthew Exp $
 *
 */

$short_opts = '';
$long_opts = array('verbose','help');

chdir(dirname($_SERVER['SCRIPT_FILENAME']));
require_once "../phplib/petcli.php";
require_once '../phplib/fns.php';
require_once '../phplib/petition.php';
require_once '../../phplib/db.php';
require_once '../../phplib/utility.php';

function verbose($str) {
    global $verbose;
    if ($verbose) 
        fwrite(STDERR, "mark-finished: $str\n");
}
function error($str) {
    fwrite(STDERR, "mark-finished: ERROR: $str\n");
}

$switches = $options[0];
$args = $options[1];
$verbose = 0; 
foreach ($switches as $switch) {
    if ($switch[0]=='--verbose') $verbose = 1;
    if ($switch[0]=='--help') {
?>

Petitions mark finished script. This is responsible for completing
petitions. It should be run daily from cron.

Usage: mark-finished [--verbose]

--help      Display this help message
--verbose   Display more information

<?
        exit;
    }
}

function find_newly_finished_petitions() {
    global $pet_today;

    verbose("finding newly finished petitions");
    /* Do a query before locking the table. */
    if (!db_getOne("
                select id from petition
                where '$pet_today' > deadline
                    and status = 'live'
                for update")) {
        verbose("... no newly finished petitions");
        return;
    }
        
    $q = db_query("
                select * from petition
                where '$pet_today' > deadline
                    and status = 'live'
                for update");
    while ($petition = db_fetch_array($q)) {
        verbose("petition #${petition['id']} (${petition['ref']}) has finished");
        db_query("update petition set status='finished', lastupdate = ms_current_timestamp()
            where id=?", $petition['id']);
        $cat = $petition['category'];
        if (!db_do("update stats set value = value::integer + 1 where key='cached_petitions_finished'"))
            db_query("insert into stats (whencounted, key, value) values (ms_current_timestamp(), 'cached_petitions_finished', 1)");
        if (!db_do("update stats set value = value::integer + 1 where key='cached_petitions_finished_$cat'"))
            db_query("insert into stats (whencounted, key, value) values (ms_current_timestamp(), 'cached_petitions_finished_$cat', 1)");
        db_query("update stats set value = value::integer - 1 where key='cached_petitions_live'");
        db_query("update stats set value = value::integer - 1 where key='cached_petitions_live_$cat'");
    }
    db_commit();
    verbose("finished newly finished petitions");
}

function find_timed_out_rejected_petitions() {
    global $pet_timestamp;

    // 29 days is 4 weeks, plus a day to allow a margin for the creator

    verbose("finding timed out rejected petitions");
    /* Do a query before locking the table. */
    if (!db_getOne("
                select id from petition
                where '$pet_timestamp' > laststatuschange + interval '29 days'
                    and status = 'rejectedonce'
                for update")) {
        verbose("... no timed out rejected petitions");
        return;
    }
        
    $q = db_query("
                select * from petition
                where '$pet_timestamp' > laststatuschange + interval '29 days'
                    and status = 'rejectedonce'
                for update");
    while ($petition = db_fetch_array($q)) {
        verbose("petition #${petition['id']} (${petition['ref']}) has timed out from rejectedonce to rejected");
        db_query("update petition set status='rejected',  
            rejection_second_categories = rejection_first_categories,
            rejection_second_reason = rejection_first_reason,
            laststatuschange = ms_current_timestamp(), lastupdate = ms_current_timestamp()
            where id=?", $petition['id']);
        $cat = $petition['category'];
        if (!db_do("update stats set value = value::integer + 1 where key = 'cached_petitions_rejected'"))
            db_query("insert into stats (whencounted, key, value) values (ms_current_timestamp(), 'cached_petitions_rejected', 1)");
        if (!db_do("update stats set value = value::integer + 1 where key = 'cached_petitions_rejected_$cat'"))
            db_query("insert into stats (whencounted, key, value) values (ms_current_timestamp(), 'cached_petitions_rejected_$cat', 1)");
        pet_send_message(intval($petition['id']), MSG_ADMIN, MSG_CREATOR, 'rejected-timeout', 'admin-rejected-timeout');
    }
    db_commit();
    verbose("finished timed out rejected petitions");
}

// Main code
find_newly_finished_petitions();
find_timed_out_rejected_petitions();


