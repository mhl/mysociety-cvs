#!/usr/bin/env python2.5
#
# nptdr-plan
# Calculate journey times across a network to a destination at a specific time,
# using the NPTDR accessibilty planning data.
#
# Copyright (c) 2008 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

# Notes:
# Does not allow for train routing guides or easements - the journeys generated
# are possible, but you have to buy the right ticket(s)


import sys
import logging
import datetime
import heapq
import pqueue

nptdr_file = "/home/francis/toobig/nptdr/sample/ATCO_040_TRAIN.CIF"
logging.basicConfig(level=logging.INFO)

sys.path.append("../../pylib")
import mysociety.atcocif

atco = mysociety.atcocif.ATCO()
atco.read(nptdr_file)
atco.index_by_short_codes()


# Run Dijkstra's algorithm to find latest departure time from all locations to
# arrive at the target location by the given time.
def do_dijkstra(atco, target_location, target_datetime):
    # The thing we're going to use for priority in the pqueue
    class Priority:
        def __init__(self, when):
            self.when = when
        # operator just for use on priority queue
        def __cmp__(self, other):
            # The priority queue pops smallest first, whereas we want
            # largest, so these are reversed from expected direction
            if self.when < other.when:
                return 1
            if self.when == other.when:
                return 0 
            if self.when > other.when:
                return -1
            assert False
        def __repr__(self):
            return "Priority '" + str(self.when) + "'"
    
    # Set up initial state
    settled = {} # dictionary from location to datetime
    queue = pqueue.PQueue()
    queue.insert(Priority(target_datetime), target_location)
    routes = {}
    routes[target_location] = [ (target_location, target_datetime) ] # how to get there

    while len(queue) > 0:
        # Find the item at top of queue
        (nearest_datetime, nearest_location) = queue.pop()
        nearest_datetime = nearest_datetime.when
        logging.info("taken " + nearest_location + " " + str(nearest_datetime) + " off queue")

        # That item is now settled
        settled[nearest_location] = nearest_datetime
        
        # Add all of its neighbours to the queue
        foundtimes = atco.adjacent_location_times(nearest_location, nearest_datetime)
        for location, when in foundtimes.iteritems():
            new_priority = Priority(when)
            try:
                # See if this location is already in queue 
                current_priority = queue[location]
                # If we get here then it is, see if what we found is nearer and update priority
                assert location not in settled
                if new_priority < current_priority:
                    queue[location] = new_priority
                    routes[location] = routes[nearest_location] + [ (location, when) ]
                    logging.info("updated " + location + " from priority " + str(current_priority) + " to " + str(new_priority) + " in queue")
            except KeyError, e:
                if location not in settled:
                    # No existing entry for location in queue
                    queue.insert(new_priority, location)
                    routes[location] = routes[nearest_location] + [ (location, when) ]
                    logging.info("added " + location + " " + str(new_priority) + " to queue")

    return (settled, routes)

#print atco.adjacent_location_times('9100AYLSBRY', datetime.datetime(2007, 10, 9, 9, 0))
#print atco.adjacent_location_times('9100AMERSHM', datetime.datetime(2007, 10, 9, 9, 0))

# Calculate shortest route from everywhere on network
target_location = '9100AMERSHM'
target_location = '9100AYLSBRY'
target_when = datetime.datetime(2007, 10, 9, 9, 0)
(results, routes) = do_dijkstra(atco, target_location, target_when)

# Output the results
s = "Journey times to " + target_location + " by " + str(target_when)
print
print s
print len(s) * '='
print

for location, when in results.iteritems():
    delta = target_when - when
    assert delta.days == 0
    print location.ljust(12) + " " + str(delta.seconds / 60) + " mins"
    route = routes[location]
    route.reverse()
    for waypoint in route:
        print "\tleave " + atco.location_details[waypoint[0]].full_location + " at " + str(waypoint[1])



