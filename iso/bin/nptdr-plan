#!/usr/bin/env python2.5
#
# nptdr-plan
# Calculate journey times across a network to a destination at a specific time,
# using the NPTDR accessibilty planning data.
#
# Copyright (c) 2008 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

# Notes:
# Does not allow for train routing guides or easements - the journeys generated
# are possible, but you have to buy the right ticket(s)


import sys
import logging
import datetime
import heapq
import pqueue

sys.path.append("../../pylib")
import mysociety.atcocif

# Parameters (should be input on the command line or via a config file)
nptdr_files = [
    "/home/francis/toobig/nptdr/sample/ATCO_040_COACH.CIF",
    "/home/francis/toobig/nptdr/sample/ATCO_040_METRO.CIF",
    "/home/francis/toobig/nptdr/sample/ATCO_040_TRAIN.CIF",
    "/home/francis/toobig/nptdr/sample/ATCO_040_BUS.CIF",
]
#target_location = '9100AYLSBRY'
target_location = '210021422650'
target_when = datetime.datetime(2007, 10, 16, 12, 0) # 15th-21st October 2007 is valid week range for 2007
output_format = 'human'
#output_format = 'for_map'
#logging.basicConfig(level=logging.DEBUG)
logging.basicConfig(level=logging.INFO)
#logging.basicConfig(level=logging.WARN)

# Run Dijkstra's algorithm to find latest departure time from all locations to
# arrive at the target location by the given time.
def do_dijkstra(atco, target_location, target_datetime):
    # The thing we're going to use for priority in the pqueue
    class Priority:
        def __init__(self, when):
            self.when = when
        # operator just for use on priority queue
        def __cmp__(self, other):
            # The priority queue pops smallest first, whereas we want
            # largest, so these are reversed from expected direction
            if self.when < other.when:
                return 1
            if self.when == other.when:
                return 0 
            if self.when > other.when:
                return -1
            assert False
        def __repr__(self):
            return "Priority '" + str(self.when) + "'"
    
    # Set up initial state
    settled = {} # dictionary from location to datetime
    queue = pqueue.PQueue()
    queue.insert(Priority(target_datetime), target_location)
    routes = {}
    routes[target_location] = [ (target_location, target_datetime) ] # how to get there

    while len(queue) > 0:
        # Find the item at top of queue
        (nearest_datetime, nearest_location) = queue.pop()
        nearest_datetime = nearest_datetime.when
        logging.info("taken " + nearest_location + " " + str(nearest_datetime) + " off queue")

        # That item is now settled
        settled[nearest_location] = nearest_datetime
        
        # Add all of its neighbours to the queue
        foundtimes = atco.adjacent_location_times(nearest_location, nearest_datetime)
        for location, when in foundtimes.iteritems():
            new_priority = Priority(when)
            try:
                # See if this location is already in queue 
                current_priority = queue[location]
                # If we get here then it is, see if what we found is nearer and update priority
                assert location not in settled
                if new_priority < current_priority:
                    queue[location] = new_priority
                    routes[location] = routes[nearest_location] + [ (location, when) ]
                    logging.info("updated " + location + " from priority " + str(current_priority) + " to " + str(new_priority) + " in queue")
            except KeyError, e:
                if location not in settled:
                    # No existing entry for location in queue
                    queue.insert(new_priority, location)
                    routes[location] = routes[nearest_location] + [ (location, when) ]
                    logging.info("added " + location + " " + str(new_priority) + " to queue")

    return (settled, routes)

#print atco.adjacent_location_times('9100AYLSBRY', datetime.datetime(2007, 10, 9, 9, 0))
#print atco.adjacent_location_times('9100AMERSHM', datetime.datetime(2007, 10, 9, 9, 0))

# Load in journey tables
atco = mysociety.atcocif.ATCO()
for nptdr_file in nptdr_files:
    atco.read(nptdr_file)
atco.index_by_short_codes()

#atco.find_journeys_crossing_midnight()

# Calculate shortest route from everywhere on network
(results, routes) = do_dijkstra(atco, target_location, target_when)

# Output the results
if output_format == 'human':
    s = "Journey times to " + target_location + " by " + str(target_when)
    print
    print s
    print len(s) * '='
    print

    for location in sorted(results.keys()):
        when = results[location]

        delta = target_when - when
        mins = delta.seconds / 60 + delta.days * 24 * 60
        print location.ljust(12) + " " + str(mins) + " mins"
        route = routes[location]
        route.reverse()
        for waypoint in route:
            print "\tleave " + atco.location_details[waypoint[0]].long_description() + " at " + str(waypoint[1])
elif output_format == 'for_map':
    for location, when in results.iteritems():
        delta = target_when - when
        secs = delta.seconds + delta.days * 24 * 60 * 60
        loc = atco.location_details[location]
        print loc.additional.grid_reference_easting + " " + loc.additional.grid_reference_northing + " " + str(secs)
    
else:
    raise Exception("Unknown output format " + output_format)




