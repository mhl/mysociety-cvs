#!/usr/bin/perl -w
#
# tflscraper:
#
# Screen scrape Transport for London journey planner.
#
# Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

# SE58AZ
#center = (532664, 176146)
#bounds = (482664, 126146) to (582664, 226146)
# SW1P4DR
#center = (529959, 178958)
#bounds = (479959, 128958) to (579959, 228958)

# SW1P4DR 20km
# center = (529959, 178958)
# bounds = (519959 539959 168958 188958)

# example use
# while [ 1 = 1 ]; do ./tflscraper >>results-SE58AZ-40km; done

my $rcsid = ''; $rcsid .= '$Id: tfl-scrape,v 1.1 2007-12-06 01:50:52 francis Exp $';

use strict;
require 5.8.0;

use Cwd;
use DBI;
use HTML::TreeBuilder;
use IO::Handle;
use Text::CSV_XS;
use WWW::Mechanize;
use Getopt::Long;

use vars qw($to $size $htmldir $deadline $walkspeed $sqlite_database $date);
my $result = GetOptions ( 
                        "to=s" => \$to,
                        "size=i" => \$size,
                        "htmldir=s" => \$htmldir,
                        "deadline=s" => \$deadline,
                        "walkspeed=i" => \$walkspeed,
                        "db=s" => \$sqlite_database,
                        "date=s" => \$date,
                        );
if (!$sqlite_database || !$to || !$htmldir || !$date) {
    print <<END;

Screen scrapes Transport for London to generate journey times to get to work at
a particular postcode, from each public transport stop. Output is both to the
SQLite database and to stdout. You should redirect stdout to a results file,
for feeding to journeys-to-grid.

Results are read first from the database if present, so you can scrape smaller
or larger areas than ones already done quicker. The database does not record
parameters like the date, or walkspeed in the journey table, so if you vary
them you should use a totally new database.

Example use:
./tfl-scrape --db=\$HOME/toobig/isodata/tfl/postcodes.sqlite --html=\$HOME/toobig/isodata/tfl/html --to=AB101AF --date=11122007 > \$HOME/toobig/isodata/tfl/results-AB101AF-20k

Required parameters:
--db=filename.sqlite - database file containing stop info, and where journeys are saved (se below)
--to=POSTCODE - postcode of destination place of work, e.g. CB30FD
--htmldir=DIR - place to dump HTML files it had trouble with, for debugging
--date=DDMMYYYY - in near future, date to do the journeys on, you probably want to pick a weekday! e.g. 06022007

Optional parameters:
--size=METRES - destination is in a centre of a square of this size sides in metres, defaults to 20,000    
--deadline=HH:MM - hard time you have to get to work by, defaults to 09:00
--walkspeed=METRES/SEC - speed of walking to/from stops, in metres per second, defaults to 1 m/s

The database should have this schema. 
    CREATE TABLE journey (
        destination text not null references postcode(postcode),
        deadline text not null,
        origin text not null references postcode(postcode),
        starttime text not null,
        endtime text not null,
        primary key(destination, deadline, origin)
    );
    CREATE TABLE postcode ( postcode text not null primary key, easting integer not null, northing integer not null );
    CREATE TABLE stop2 ( name text not null, type text not null, easting integer not null, northing integer not null, postcode_closest text not null );
    CREATE INDEX jourey_destination_deadline_idx on journey(destination, deadline);
    CREATE INDEX postcode_easting_idx on postcode(easting);
    CREATE INDEX postcode_northing_idx on postcode(northing);
    CREATE INDEX stop2_easting_idx on stop2(easting);
    CREATE INDEX stop2_name_idx on stop2(name);
    CREATE INDEX stop2_northing_idx on stop2(northing);
    CREATE INDEX stop2_type_idx on stop2(type);

The postcode table should pre-contain the coordinates of every relevant
postcode (there are 1.7 million of them in the whole country). See
postcode-into-db for script to do this. Example row:
    AB101AF|394181|806429
The stop2 table should contain the coordinates of all relevant public transport
stops from NaPTAN. See stops-into-db for script to do this. Example row:
    Bus Station Bay 19|BCT|358942|173527|BS13LP

Postcodes are in uppercase with no spaces. Coordinates are an integer representation
of the 3 decimal plae OS national grid square references - i.e. are measured in
metres.0

END
    exit;
}

$size ||= 20000;
$deadline ||= '09:00';
$walkspeed ||= 1;  # m/s

my $counter = 0;
sub dump_page ($) {
    my $m = shift;
    open(H, ">$htmldir/$counter.html");
    H->print($m->content());
    close(H);
    print STDERR "$htmldir/$counter.html\n";
    ++$counter;
}

sub trim ($) {
    my $s = shift;
    $s =~ s/^\s+//s;
    $s =~ s/\s+$//s;
    return $s;
}

my $timere = qr/^([01][0-9]|2[0-3]):([0-5][0-9])$/;

sub time_add_minutes ($$) {
    my ($time, $mins) = @_;
    my ($H, $M) = ($time =~ $timere);
    die "invalid time '$time' in time_add_minutes" if (!defined($H));
    $M += $mins;
    while ($M > 59) {
        $M -= 60;
        ++$H;
    }
    while ($M < 0) {
        $M += 60;
        --$H;
    }
    return sprintf('%02d:%02d', $H, $M);
}

# time_diff_minutes A B
# Return A - B in minutes.
sub time_diff_minutes ($$) {
    my ($A, $B) = @_;
    my ($Ha, $Ma) = ($A =~ $timere);
    die "invalid time '$A' as first argument to time_diff_minutes"
        if (!defined($Ha));
    my ($Hb, $Mb) = ($B =~ $timere);
    die "invalid time '$B' as first argument to time_diff_minutes"
        if (!defined($Hb));
    
    return $Ma - $Mb + 60 * ($Ha - $Hb);
}

my $dbh = DBI->connect("dbi:SQLite:dbname=$sqlite_database", "", "", { AutoCommit => 0 });

my $M = new WWW::Mechanize();
$M->agent_alias('Windows IE 6');

# get_latest_journey_before DEADLINE FROM TO
# Get the latest-starting journey which reaches TO before DEADLINE.
sub get_latest_journey_before ($$$;$);
sub get_latest_journey_before ($$$;$) {
    my ($deadline, $from, $to, $nonearbypc) = @_;

    my ($hour, $minute) = split(/:/, $deadline);
    $hour =~ s/^0//;
    $minute =~ s/^0//;

    warn "get... ";
    $M->get('http://journeyplanner.tfl.gov.uk/user/XSLT_TRIP_REQUEST2?language=en');
#    warn $M->content();
    warn "submit form... ";
    $date =~ m/^(\d\d)(\d\d)(\d\d\d\d)$/;
    my $dateday = $1;
    my $dateyearmonth = "$3$2";
    $M->submit_form(
            form_number => 2,
            fields => {
                type_origin => 'locator',
                name_origin => $from,
                type_destination => 'locator',
                name_destination => $to,

                itdTripDateTimeDepArr => 'arr',
                itdDateDay => $dateday,
                itdDateYearMonth => $dateyearmonth,
                itdTimeHour => $hour,
                itdTimeMinute => $minute
            }
        );
    warn "done\n";

    if ($M->content() =~ /no record of those locations/) {
        return () if ($nonearbypc);
        # We just used a postcode that TFL don't know. So try the closest
        # available postcode.
        warn "  -> bad postcode $from; trying a nearby one instead...\n";
        my ($E, $N) = $dbh->selectrow_array('select easting, northing from postcode where postcode = ?', {}, $from);
        my ($pc) = @{$dbh->selectcol_arrayref("select postcode from postcode where easting > $E - 25 and easting < $E + 25 and northing > $N - 25 and northing < $N + 25 and postcode <> '$from' order by random() limit 1")};
        $dbh->commit();
        if (defined($pc)) {
            warn "    trying $pc\n";
            return get_latest_journey_before($deadline, $pc, $to, 1);
        } else {
            warn "    can't find a nearby postcode, giving up on this one\n";
            return ();
        }
        
    }

#    print $M->content();

    my $triedearlier = 0;
earlier:

    my $html = HTML::TreeBuilder->new_from_content($M->content());
#    my $table = $html->look_down(_tag => 'table', class => 'datatable-3');
#    if (!$table) {
        open(D, ">$htmldir/dump.html");
        print D $M->content();
        close(D);
#        print STDERR "$htmldir/dump.html\n";
#        warn "can't find results table in journey $from -> $to";
#        return ();
#    }

#    my $tbody = $table->look_down(_tag => 'tbody')
#        || die "can't find results tbody in journey $origin -> $destination";

    my ($starttime, $endtime);
    foreach my $tr ($html->look_down(_tag => 'table')) {
        my @td = $tr->look_down(_tag => 'td');
        next if (@td == 0);
#        last unless (@td == 8);

        my ($n, $depart, $arrive, $duration) = map { trim($_->content()->[0]) } @td;

#        print STDERR "$n '$depart' -> '$arrive' ($duration)\n";
        next unless ($depart =~ /^\d\d:\d\d/ && $arrive =~ /^\d\d:\d\d/);

        $arrive =~ s/,.+$//;
        $depart =~ s/,.+$//;

#        print STDERR "$from $depart -> $arrive $to\n";
        
        if ($arrive le $deadline && (!defined($starttime) || $depart gt $starttime)) {
            $starttime = $depart;
            $endtime = $arrive;
        }
    }

    if (!defined($starttime)) {
        if (!$triedearlier) {
            print STDERR "no results; trying earlier...\n";
            $triedearlier = 1;
            $M->submit_form(
                    form_number => 1,
                    fields => {
                        command => 'tripPrev'
                    }
                );
#            $M->follow_link(text_regex => qr/Earlier/)
#                or die "no 'earlier' link";
            goto earlier;
        }
    
        open(H, ">$htmldir/dump.html");
        print H $M->content();
        close(H);
        print STDERR "$htmldir/dump.html\n";
        warn "no results for $from -> $to\n";
        return ();
    }

    return ($starttime, $endtime);
}

my ($E, $N) = $dbh->selectrow_array('select easting, northing from postcode where postcode = ?', {}, $to);
die "no location for destination postcode '$to'" if (!defined($E));

# Bounds of rectangle.
my $WW = $E - $size / 2;
my $EE = $E + $size / 2;
my $SS = $N - $size / 2;
my $NN = $N + $size / 2;

warn "center = ($E, $N)\n";
warn "bounds = ($WW $EE $SS $NN)\n";

printf "%d %d 0\n", $E, $N;

#$WW = 500000;
#$EE = 600000;
#$SS = 200000;
#$NN = 300000;

my $Nalready = $dbh->selectrow_array('select count(*) from journey where destination = ? and deadline = ?', {}, $to, $deadline);

my $from;

# Find all the public transport stops within the region. For each one, find the
# postcode nearest to that stop, and find the journey time from that postcode
# to the destination.

my @stops = @{$dbh->selectall_arrayref("select easting, northing, name, postcode_closest from stop2 where easting > $WW - 500 and easting < $EE + 500 and northing > $SS - 500 and northing < $NN + 500 order by random()")};

warn "have $Nalready of " . scalar(@stops). " results so far\n";

foreach my $s (@stops) {
    my ($stopE, $stopN, $stopname, $pc) = @$s;

    # Find location of nearest postcode.
    my ($E, $N) = $dbh->selectrow_array("select easting, northing from postcode where postcode = ?", {}, $pc);
    if (!defined($pc)) {
        warn "no postcode near $stopname\n";
        next;
    }

    my $dist = sqrt(($stopE - $E) ** 2 + ($stopN - $N) ** 2);
    printf STDERR "%s -> %s (%fm)\n", $stopname, $pc, $dist;

    # Now see if we already have a reading for this postcode.
    my $time = $dbh->selectrow_array('select starttime from journey where journey.origin = ? and destination = ? and deadline = ?', {}, $pc, $to, $deadline);

    $dbh->commit();

    if (defined($time)) {
        if ($time) {
            warn "  already have start time $time\n";
            printf "%d %d %f\n", $stopE, $stopN, 60 * time_diff_minutes($deadline, $time) - ($dist / $walkspeed);
        } else {
            warn "  no journey possible\n";
        }
        next;
    }

    #warn "doing...\n";
    my ($start, $end) = get_latest_journey_before($deadline, $pc, $to);
 
    if (defined($start)) {
        warn "  start time is $start\n";
        printf "%d %d %f\n", $stopE, $stopN, 60 * time_diff_minutes($deadline, $start) - ($dist / $walkspeed) / 60;
        $dbh->do('insert into journey (destination, deadline, origin, starttime, endtime) values (?, ?, ?, ?, ?)', {}, $to, $deadline, $pc, $start, $end);
    } else {
        warn "  impossible to get there from here\n";
        $dbh->do('insert into journey (destination, deadline, origin, starttime, endtime) values (?, ?, ?, ?, ?)', {}, $to, $deadline, $pc, '', '');
    }
    $dbh->commit();
}

