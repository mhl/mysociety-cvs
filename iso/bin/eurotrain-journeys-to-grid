#! /usr/bin/tcc -run -lgd -I/usr/local/ncarg/include/ncarg/ -lncarg -lngmath -L/usr/local/ncarg/lib/
/*
 * eurotrain-journeys-to-grid:
 * vim:syntax=c
 *
 * Convert journeys text file into a grid file, for feeding into grid-to-ppm.
 * The journeys file is times to arrive at work from public transport stops,
 * this script includes extra time to walk to the stop.
 *
 * Input file is space separated north(lat), east(lon), time-in-secs
 *
 * Paramters are:
 * west, east, south, north boundary
 * width, height (pixels)
 * walk speed in m/s (choose 1 m/s)
 * max walk time in seconds (15 mins = 900 secs)
 *
 * XXX remove unused types (i.e. other than grid)
 *
 * Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
 * Email: chris@mysociety.org; WWW: http://www.mysociety.org/
 *
 */

static const char rcsid[] = "$Id: eurotrain-journeys-to-grid,v 1.2 2008-04-28 09:49:57 francis Exp $";

#include <assert.h>
#include <gd.h>
#include <math.h>
#include <pnm.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define err(...)    do { fprintf(stderr, "eurotrain-journeys-to-grid: "); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); } while (0)
#define die(...)    do { err(__VA_ARGS__); exit(1); } while (0)

#define debug(...)  err(__VA_ARGS__)

struct point {
    float E, N, time;
};

#define TIME_INFINITY       10000000.  /* This is over 24 hours */

/* point_sorter A B
 * qsort(3) callback to compare northings of A and B. */
int point_sorter(const void *a, const void *b) {
    const struct point *pa, *pb;
    pa = (const struct point*)a;
    pb = (const struct point*)b;
    if (pa->N < pb->N)
        return -1;
    else if (pa->N > pb->N)
        return +1;
    else
        return 0;
}

/* float_sorter A B
 * qsort(3) callback to sort floats. */
int float_sorter(const void *a, const void *b) {
    const float *fa, *fb;
    fa = (const float*)a;
    fb = (const float*)b;
    if (*fa < *fb)
        return -1;
    else if (*fa > *fb)
        return +1;
    else
        return 0;
}

/* List of points at which we have journey times. */
struct point *pp;
size_t npp, nppalloc;

/* mintime E N
 * Return the minimum time for a journey from (E, N) to the destination, or
 * TIME_INFINITY if no journey is possible. */
float mintime(const float E, const float N, const float maxwalkdist, const float walkspeed) {
    int i0, i1, i;
    static int il, ih;
    static float last_N;
    float min = TIME_INFINITY;

    if (N != last_N) {
        /* Search for points within maxwalkdist of this one. */
        i0 = 0;
        i1 = npp - 1;
        while (i1 > i0 + 1) {
            i = (i0 + i1) / 2;
            // fprintf(stderr, "ppN:%f N: %f maxwalkdist:%f\n", pp[i].N, N, maxwalkdist);
            if (pp[i].N > N - maxwalkdist)
                i1 = i;
            else if (pp[i].N < N - maxwalkdist)
                i0 = i;
            else
                break;
        }

        il = i0;

        i0 = 0;
        i1 = npp - 1;
        while (i1 > i0 + 1) {
            i = (i0 + i1) / 2;
            if (pp[i].N > N + maxwalkdist)
                i1 = i;
            else if (pp[i].N < N + maxwalkdist)
                i0 = i;
            else
                break;
        }

        ih = i1;

        last_N = N;
    }

    for (i = il; i <= ih; ++i) {
        float d, t;
        d = hypot(E - pp[i].E, N - pp[i].N);
        if (d > maxwalkdist)
            continue;
        t = d / walkspeed;
        // fprintf(stderr, "ppE:%f E:%f ppN:%f N:%f maxwalkdist:%f d:%f pptime:%f d/walkspeed:%f\n", pp[i].N, N, pp[i].E, E, maxwalkdist, d, pp[i].time, t);
        t += pp[i].time;
        if (t < 0) {
            // ignore negative times - effectively infinite
            fprintf(stderr, "< 0 for %f - d: %f walkspeed: %f pptime: %f\n", t, d, walkspeed, pp[i].time);
        } else if (t < min)
            min = t;

    }

    return min;
}

int parse_float(const char *s, float *f) {
    return 1 == sscanf(s, "%f", f);
}

int parse_int(const char *s, int *i) {
    return 1 == sscanf(s, "%d", i);
}

float frand(void) {
    return rand() / (float)RAND_MAX;
}

double fmax(const double a, const double b) {
    return a > b ? a : b;
}

void do_grid(const bool plain, const int width, const int height, const float west, const float east, const float south, const float north, const float maxwalkdist, const float walkspeed) {
    int x, y;

    for (y = 0; y < height; ++y) {
        float N;
        N = south + (north - south) * (height - y - 1) / (float)(height - 1);

        for (x = 0; x < width; ++x) {
            float E, t;
            E = west + (east - west) * x / (float)(width - 1);
            t = mintime(E, N, maxwalkdist, walkspeed);
            // fprintf(stderr, "found time %f\n", t);

            if (plain)
                printf("%f %f %f\n", E, N, t);
            else
                fwrite(&t, sizeof t, 1, stdout);
        }
        if (plain)
            printf("\n");
    }
}

int main(int argc, char *argv[]) {
    float west, east, south, north, walkspeed, maxwalktime, maxwalkdist;
    int width, height;
    enum { m_query = 0, m_grid = 1, m_plaingrid = 2 } mode = m_query;
    const unsigned numargs[7] = { 3, 8, 8 };
    FILE *fp;
    
    fp = stdin;
    srand(time(NULL));

    if (argc < 2)
        die("first argument gives mode");

    if (0 == strcmp(argv[1], "query"))
        mode = m_query;
    else if (0 == strcmp(argv[1], "grid"))
        mode = m_grid;
    else if (0 == strcmp(argv[1], "plaingrid"))
        mode = m_plaingrid;
    else
        die("unknown mode '%s'", argv[1]);

    ++argv;
    --argc;

    if (argc - 1 != numargs[mode])
        die("need %d arguments", numargs[mode]);
 
    if (mode == m_query) {
        if (!(fp = fopen(argv[1], "r")))
            die("%s: %s", argv[1], strerror(errno));
        if (!parse_float(argv[2], &walkspeed)) /* probably want 1 m/s */
            die("bad walk speed '%s'", argv[2]);
        if (!parse_float(argv[3], &maxwalktime)) /* probably want 15 minutes = 900 seconds*/
            die("bad max walk time '%s'", argv[3]);
    } else {
        if (!parse_float(argv[1], &west))
            die("bad west boundary '%s'", argv[1]);
        if (!parse_float(argv[2], &east))
            die("bad east boundary '%s'", argv[2]);
        if (!parse_float(argv[3], &south))
            die("bad south boundary '%s'", argv[3]);
        if (!parse_float(argv[4], &north))
            die("bad north boundary '%s'", argv[4]);
        if (!parse_int(argv[5], &width))
            die("bad width '%s'", argv[5]);
        if (!parse_int(argv[6], &height))
            die("bad height '%s'", argv[6]);
        if (!parse_float(argv[7], &walkspeed))
            die("bad walk speed '%s'", argv[7]);
        if (!parse_float(argv[8], &maxwalktime))
            die("bad max walk time '%s'", argv[8]);
    }

    maxwalkdist = maxwalktime * walkspeed;
    
    pp = malloc((nppalloc = 16) * sizeof *pp);
    
    while (3 == fscanf(fp, "%f %f %f\n",
                        &pp[npp].N, &pp[npp].E, &pp[npp].time)) {
        ++npp;
        if (npp == nppalloc)
            pp = realloc(pp, (nppalloc *= 2) * sizeof *pp);
    }

    debug("have %d points", npp);
    debug("max walk dist = %f", maxwalkdist);

    qsort(pp, npp, sizeof *pp, point_sorter);

    if (mode == m_query) {
        float E, N;
        while (2 == scanf("%f %f", &E, &N)) {
            float t;
            t = mintime(E, N, maxwalkdist, walkspeed);
            if (t == TIME_INFINITY) t = -1;
            printf("%f %f %f\n", E, N, t);
        }
    } else if (mode == m_grid || mode == m_plaingrid)
        do_grid(mode == m_plaingrid, width, height, west, east, south, north, maxwalkdist, walkspeed);
    else
        abort();

    return 0;
}

