#! /usr/bin/tcc -run -lgd -I/usr/local/ncarg/include/ncarg/ -lncarg -lngmath -L/usr/local/ncarg/lib/
/*
 * eurotrain-journeys-to-grid:
 * vim:syntax=c
 *
 * Convert journeys text file into a grid file, for feeding into grid-to-ppm.
 * The journeys file is times to arrive at work from public transport stops,
 * this script includes extra time to walk (drive!) to the stop.
 *
 * Input file is space separated north(lat), east(lon), time-in-secs
 *
 * Paramters are:
 * west, east, south, north boundary
 * width, height (pixels)
 * walk speed in m/s (choose 1 m/s)
 * max walk time in seconds (15 mins = 900 secs)
 *
 * XXX remove unused types (i.e. other than grid)
 *
 * Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
 * Email: chris@mysociety.org; WWW: http://www.mysociety.org/
 *
 */

static const char rcsid[] = "$Id: eurotrain-journeys-to-grid,v 1.4 2008-04-29 00:31:13 francis Exp $";

#include <assert.h>
#include <gd.h>
#include <math.h>
#include <pnm.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define err(...)    do { fprintf(stderr, "eurotrain-journeys-to-grid: "); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); } while (0)
#define die(...)    do { err(__VA_ARGS__); exit(1); } while (0)

#define debug(...)  err(__VA_ARGS__)

struct point {
    float E, N, time;
};

#define TIME_INFINITY       10000000.  /* This is over 24 hours */

/* point_sorter A B
 * qsort(3) callback to compare northings of A and B. */
int point_sorter(const void *a, const void *b) {
    const struct point *pa, *pb;
    pa = (const struct point*)a;
    pb = (const struct point*)b;
    if (pa->N < pb->N)
        return -1;
    else if (pa->N > pb->N)
        return +1;
    else
        return 0;
}

/* float_sorter A B
 * qsort(3) callback to sort floats. */
int float_sorter(const void *a, const void *b) {
    const float *fa, *fb;
    fa = (const float*)a;
    fb = (const float*)b;
    if (*fa < *fb)
        return -1;
    else if (*fa > *fb)
        return +1;
    else
        return 0;
}

/* List of points at which we have journey times. */
struct point *pp;
size_t npp, nppalloc;

/* radians deg
 * Convert degrees to radians.
 */ 
double radians(double deg) {
    return deg * M_PI / 180.0;
}
/* degrees rad
 * Convert radians to degrees
 */
double degrees(double rad) {
    return rad * 180.0 / M_PI;
}

/*  Convert lat/lon to pixels for:
    OpenStreetMap zoom 5, tiles 15,8 to 19,12 */
double minx = -11.25; // Degrees
double maxx = 45;
double miny = 0.187499652486244; // Translated
double maxy = 0.499999073296651;
double wgs84_to_map(double size, double lat, double lon, double* x, double* y) {
    *x = size * (lon-minx) / (maxx-minx);
    *y = log(tan(radians(lat)) + 1/cos(radians(lat)))/M_PI; // Y is now from -1 to 1
    *y = size * (1 - (*y-miny) / (maxy-miny));
}
/* Reverse of above function */
double map_to_wgs84(double size, double x, double y, double* lat, double* lon) {
    *lon = (x / size) * (maxx-minx) + minx;
    *lat = M_PI * ((1 - (y / size)) * (maxy-miny) + miny); // lat is now from -PI to PI
    // tan(radians(lat)) + 1/cos(radians(lat)) == exp(y);
    // tan(radians(-lat)) + 1/cos(radians(lat)) == exp(-y);
    // Subtracting: 2 * tan(radians(lat)) == exp(y) - exp(-y)
    *lat = degrees(atan((exp(*lat) - exp(-*lat)) / 2));
}

/* great_circle_distance lat1(n) lon1(e) lat2(n) lon2(e) 
 * Distance over surface of the earth between lat/lon pairs.
 * Taken from pb/db/schema.sql 
 * See http://www.ga.gov.au/geodesy/datums/distance.jsp */
#define RADIUS_OF_EARTH 6372800 /* metres */
double great_circle_distance(const double lat1, const double lon1, const double lat2, const double lon2) {
    return RADIUS_OF_EARTH * acos(
        (sin(radians(lat1)) * sin(radians(lat2))
        + cos(radians(lat1)) * cos(radians(lat2))
        * cos(radians(lon2 - lon1)))
    );
}


/* mintime E N
 * Return the minimum time for a journey from (E, N) to the destination, or
 * TIME_INFINITY if no journey is possible. */
float mintime(const float E, const float N, const float maxwalkdist, const float walkspeed) {
    int i0, i1, i;
    static int il, ih;
    static float last_N;
    float min = TIME_INFINITY;

    /* Search for points within maxwalkdist of this one. */
    if (N != last_N) {
        /* npp is sorted by northings. Binary search to find low index any points must be within */
        i0 = 0;
        i1 = npp - 1;
        while (i1 > i0 + 1) {
            i = (i0 + i1) / 2;
            // fprintf(stderr, "ppN:%f N: %f maxwalkdist:%f\n", pp[i].N, N, maxwalkdist);
            if (pp[i].N > N - maxwalkdist)
                i1 = i;
            else if (pp[i].N < N - maxwalkdist)
                i0 = i;
            else
                break;
        }

        il = i0;

        /* And binary sort to find the highest index that the points near the northing must be within */
        i0 = 0;
        i1 = npp - 1;
        while (i1 > i0 + 1) {
            i = (i0 + i1) / 2;
            if (pp[i].N > N + maxwalkdist)
                i1 = i;
            else if (pp[i].N < N + maxwalkdist)
                i0 = i;
            else
                break;
        }

        ih = i1;

        last_N = N;
    }

    /* Now il, ih is an index range within which all points a maxwalkdist north/south must be */

    /* Straightforward scan through all points to find the nearest one */
    for (i = il; i <= ih; ++i) {
        float d, t;
        d = hypot(E - pp[i].E, N - pp[i].N);
        if (d > maxwalkdist)
            continue;
        t = d / walkspeed;
//        fprintf(stderr, "ppE:%f E:%f ppN:%f N:%f maxwalkdist:%f d:%f pptime:%f d/walkspeed:%f\n", pp[i].N, N, pp[i].E, E, maxwalkdist, d, pp[i].time, t);
        t += pp[i].time;
        if (t < 0) {
            // ignore negative times - effectively infinite
            fprintf(stderr, "< 0 for %f - d: %f walkspeed: %f pptime: %f\n", t, d, walkspeed, pp[i].time);
        } else if (t < min)
            min = t;

    }

    return min;
}

int parse_float(const char *s, float *f) {
    return 1 == sscanf(s, "%f", f);
}

int parse_int(const char *s, int *i) {
    return 1 == sscanf(s, "%d", i);
}

float frand(void) {
    return rand() / (float)RAND_MAX;
}

double fmax(const double a, const double b) {
    return a > b ? a : b;
}

void do_grid(const bool plain, const int width, const int height, const float west, const float east, const float south, const float north, const float maxwalkdist, const float walkspeed) {
    int x, y;

    for (y = 0; y < height; ++y) {
        float N;
        N = south + (north - south) * (height - y - 1) / (float)(height - 1);

        for (x = 0; x < width; ++x) {
            float E, t;
            E = west + (east - west) * x / (float)(width - 1);
            t = mintime(E, N, maxwalkdist, walkspeed);
            fprintf(stderr, "found time %f\n", t);

            if (plain)
                printf("%f %f %f\n", E, N, t);
            else
                fwrite(&t, sizeof t, 1, stdout);
        }
        if (plain)
            printf("\n");
    }
}

int main(int argc, char *argv[]) {
    float west, east, south, north, walkspeed, maxwalktime, maxwalkdist;
    int width, height;
    enum { m_query = 0, m_grid = 1, m_plaingrid = 2 } mode = m_query;
    const unsigned numargs[7] = { 3, 8, 8 };
    FILE *fp;

/* Testing individual functions
    double mapx, mapy;
    wgs84_to_map(1280, 52.516667, 13.416667, &mapx, &mapy);
    printf("mapx, mapy: %f %f\n", mapx, mapy);
    double lat, lon;
    map_to_wgs84(1280, 561.303711288889, 638.730705204974, &lat, &lon);
    printf("reverse: lat, lon: %f %f\n", lat, lon);

    double dist = great_circle_distance(51.507778, -0.128056, 48.866667, 2.333056);
    printf("London to Paris: %fm\n", dist);
    return 0;
   */ 
    
    fp = stdin;
    srand(time(NULL));

    if (argc < 2)
        die("first argument gives mode");

    if (0 == strcmp(argv[1], "query"))
        mode = m_query;
    else if (0 == strcmp(argv[1], "grid"))
        mode = m_grid;
    else if (0 == strcmp(argv[1], "plaingrid"))
        mode = m_plaingrid;
    else
        die("unknown mode '%s'", argv[1]);

    ++argv;
    --argc;

    if (argc - 1 != numargs[mode])
        die("need %d arguments", numargs[mode]);
 
    if (mode == m_query) {
        if (!(fp = fopen(argv[1], "r")))
            die("%s: %s", argv[1], strerror(errno));
        if (!parse_float(argv[2], &walkspeed)) /* probably want 1 m/s */
            die("bad walk speed '%s'", argv[2]);
        if (!parse_float(argv[3], &maxwalktime)) /* probably want 15 minutes = 900 seconds*/
            die("bad max walk time '%s'", argv[3]);
    } else {
        if (!parse_float(argv[1], &west))
            die("bad west boundary '%s'", argv[1]);
        if (!parse_float(argv[2], &east))
            die("bad east boundary '%s'", argv[2]);
        if (!parse_float(argv[3], &south))
            die("bad south boundary '%s'", argv[3]);
        if (!parse_float(argv[4], &north))
            die("bad north boundary '%s'", argv[4]);
        if (!parse_int(argv[5], &width))
            die("bad width '%s'", argv[5]);
        if (!parse_int(argv[6], &height))
            die("bad height '%s'", argv[6]);
        if (!parse_float(argv[7], &walkspeed))
            die("bad walk speed '%s'", argv[7]);
        if (!parse_float(argv[8], &maxwalktime))
            die("bad max walk time '%s'", argv[8]);
    }

    maxwalkdist = maxwalktime * walkspeed;
    
    pp = malloc((nppalloc = 16) * sizeof *pp);
    
    while (3 == fscanf(fp, "%f %f %f\n",
                        &pp[npp].N, &pp[npp].E, &pp[npp].time)) {
        ++npp;
        if (npp == nppalloc)
            pp = realloc(pp, (nppalloc *= 2) * sizeof *pp);
    }

    debug("have %d points", npp);
    debug("max walk dist = %f", maxwalkdist);

    qsort(pp, npp, sizeof *pp, point_sorter);

    if (mode == m_query) {
        float E, N;
        while (2 == scanf("%f %f", &E, &N)) {
            float t;
            t = mintime(E, N, maxwalkdist, walkspeed);
            if (t == TIME_INFINITY) t = -1;
            printf("%f %f %f\n", E, N, t);
        }
    } else if (mode == m_grid || mode == m_plaingrid)
        do_grid(mode == m_plaingrid, width, height, west, east, south, north, maxwalkdist, walkspeed);
    else
        abort();

    return 0;
}

