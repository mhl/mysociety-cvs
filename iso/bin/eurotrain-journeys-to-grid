#! /usr/bin/tcc -run -lgd
/*
 * eurotrain-journeys-to-grid:
 * vim:syntax=c
 *
 * Convert journeys text file into a grid file, for feeding into grid-to-ppm.
 * The journeys file is times to arrive at work from public transport stops,
 * this script includes extra time to walk (drive!) to the stop.
 *
 * Input file is space separated north(lat), east(lon), time-in-secs
 *
 * Paramters are:
 * west, east, south, north boundary
 * width, height (pixels)
 * walk speed in m/s (choose 1 m/s)
 * max walk time in seconds (15 mins = 900 secs)
 *
 * Projections:
 * The input file of travel times is in lat/lon.
 * The input rectangle, and the pixel width/height, are in a square mercator
 * projection mapping to pixels, as described by function wgs84_to_map.
 *
 * XXX remove unused types (i.e. other than grid)
 *
 * Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
 * Email: chris@mysociety.org; WWW: http://www.mysociety.org/
 *
 */

static const char rcsid[] = "$Id: eurotrain-journeys-to-grid,v 1.13 2008-12-11 12:44:51 francis Exp $";

#include <assert.h>
#include <gd.h>
#include <math.h>
#include <pnm.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define err(...)    do { fprintf(stderr, "eurotrain-journeys-to-grid: "); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); } while (0)
#define die(...)    do { err(__VA_ARGS__); exit(1); } while (0)

//#define debug(...)    do { fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); } while (0)
#define debug(...)    do { } while (0)

struct point {
    double E, N, time;
    char *label;
};

#define TIME_INFINITY       10000000.  /* This is over 24 hours */

/* point_sorter A B
 * qsort(3) callback to compare northings of A and B. */
int point_sorter(const void *a, const void *b) {
    const struct point *pa, *pb;
    pa = (const struct point*)a;
    pb = (const struct point*)b;
    if (pa->N < pb->N)
        return -1;
    else if (pa->N > pb->N)
        return +1;
    else
        return 0;
}

/* double_sorter A B
 * qsort(3) callback to sort doubles. */
int double_sorter(const void *a, const void *b) {
    const double *fa, *fb;
    fa = (const double*)a;
    fb = (const double*)b;
    if (*fa < *fb)
        return -1;
    else if (*fa > *fb)
        return +1;
    else
        return 0;
}

/* List of points at which we have journey times. */
struct point *pp;
size_t npp, nppalloc;

/* radians deg
 * Convert degrees to radians.
 */ 
double radians(double deg) {
    return deg * M_PI / 180.0;
}
/* degrees rad
 * Convert radians to degrees
 */
double degrees(double rad) {
    return rad * 180.0 / M_PI;
}

/*  Convert lat/lon to pixels for:
    OpenStreetMap zoom 5, tiles 15,8 to 19,12 */
double minx = -11.25; // Degrees
double maxx = 45.0;
double miny = 0.187499652486244; // Translated
double maxy = 0.499999073296651;
double wgs84_to_map(double size, double lat, double lon, double* x, double* y) {
    *x = size * (lon-minx) / (maxx-minx);
    *y = log(tan(radians(lat)) + 1/cos(radians(lat)))/M_PI; // Y is now from -1 to 1
    *y = size * (1 - (*y-miny) / (maxy-miny));
}
/* Reverse of above function */
double map_to_wgs84(double size, double x, double y, double* lat, double* lon) {
    *lon = (x / size) * (maxx-minx) + minx;
    *lat = M_PI * ((1 - (y / size)) * (maxy-miny) + miny); // lat is now from -PI to PI
    // tan(radians(lat)) + 1/cos(radians(lat)) == exp(y);
    // tan(radians(-lat)) + 1/cos(radians(lat)) == exp(-y);
    // Subtracting: 2 * tan(radians(lat)) == exp(y) - exp(-y)
    *lat = degrees(atan((exp(*lat) - exp(-*lat)) / 2));
    debug("map_to_wgs84 size:%lf x:%lf y:%lf lat:%lf lon:%lf", size, x, y, *lat, *lon);
    debug("map_to_wgs84 minx:%lf maxx:%lf miny:%lf maxy:%lf", minx, maxx, miny, maxy);
}

/* great_circle_distance lat1(n) lon1(e) lat2(n) lon2(e) 
 * Distance over surface of the earth between lat/lon pairs.
 * Taken from pb/db/schema.sql 
 * See http://www.ga.gov.au/geodesy/datums/distance.jsp */
#define RADIUS_OF_EARTH 6372800 /* metres */
double great_circle_distance(const double lat1, const double lon1, const double lat2, const double lon2) {
    return RADIUS_OF_EARTH * acos(
        (sin(radians(lat1)) * sin(radians(lat2))
        + cos(radians(lat1)) * cos(radians(lat2))
        * cos(radians(lon2 - lon1)))
    );
}


/* size mintime E N
 * Return the minimum time for a journey from (E, N) (in pixel map coordinates, size is square size)
 to the destination, or TIME_INFINITY if no journey is possible. Returns the text label for the
 city used via the label pointer. */
double mintime(const double size, const double E, const double N, const double maxwalkdist, const double walkspeed, char **label) {
    int i0, i1, i;
    static int il, ih;
    static double last_lat;
    double min = TIME_INFINITY;
    double lat, lon;

    *label = NULL;

    // LATITUDE IS NORTHLY
    // LONGITUDE IS EASTLY

    /* Find where we are in lat / lon space */
    map_to_wgs84(size, E, N, &lat, &lon);

    /* Search for points within maxwalkdist of this one. */
    if (lat != last_lat) {
        /* npp is sorted by northings. Binary search to find low index any points must be within */
        i0 = 0;
        i1 = npp - 1;
        while (i1 > i0 + 1) {
            i = (i0 + i1) / 2;
            debug("upper i:%d ppN(lat):%lf lat: %lf maxwalkdist:%lf", i, pp[i].N, lat, maxwalkdist);

            if (radians(pp[i].N) > radians(lat) - (maxwalkdist / RADIUS_OF_EARTH))
                i1 = i;
            else if (radians(pp[i].N) < radians(lat) - (maxwalkdist / RADIUS_OF_EARTH))
                i0 = i;
            else
                break;
        }

        il = i0;

        /* And binary sort to find the highest index that the points near the northing must be within */
        i0 = 0;
        i1 = npp - 1;
        while (i1 > i0 + 1) {
            i = (i0 + i1) / 2;
            debug("lower i:%d ppN(lat):%lf lat: %lf maxwalkdist:%lf", i, pp[i].N, lat, maxwalkdist);
            if (radians(pp[i].N) > radians(lat) + (maxwalkdist / RADIUS_OF_EARTH))
                i1 = i;
            else if (radians(pp[i].N) < radians(lat) + (maxwalkdist / RADIUS_OF_EARTH))
                i0 = i;
            else
                break;
        }

        ih = i1;

        last_lat = lat;
    }

    /* Now il, ih is an index range within which all points a maxwalkdist north/south must be */
    debug("Indices min: %d max: %d", il, ih);

    /* Straightforward scan through all points to find the nearest one */
    double used_lat, used_lon;
    for (i = il; i <= ih; ++i) {
        double d, t;
        d = great_circle_distance(lat, lon, pp[i].N, pp[i].E);
        //d = hypot(E - pp[i].E, N - pp[i].N);
        if (d > maxwalkdist)
            continue;
        t = d / walkspeed;
        t += pp[i].time;
        if (t < 0) {
            // ignore negative times - effectively infinite
            fprintf(stderr, "< 0 for %lf - d: %lf walkspeed: %lf pptime: %lf\n", t, d, walkspeed, pp[i].time);
        } else if (t < min) {
            debug("ppN(lat):%lf lat:%lf ppE(lon):%lf lon:%lf maxwalkdist:%lf walkd:%lf traintime:%lf train+walktime:%lf", pp[i].N, lat, pp[i].E, lon, maxwalkdist, d, pp[i].time, t);
            used_lat = pp[i].N;
            used_lon = pp[i].E;
            *label = pp[i].label;
            min = t;
        }

    }

    //fprintf(stderr, "time %lf for N:%lf E:%lf lat:%lf lon:%lf used_lat:%lf used_lon:%lf\n", min, N, E, lat, lon, used_lat, used_lon);

    return min;
}

int parse_double(const char *s, double *f) {
    return 1 == sscanf(s, "%lf", f);
}

int parse_int(const char *s, int *i) {
    return 1 == sscanf(s, "%d", i);
}

double frand(void) {
    return rand() / (double)RAND_MAX;
}

double fmax(const double a, const double b) {
    return a > b ? a : b;
}

void print_escape_xml(char *l) {
    while (*l) {
        // printf("%c\n", *l);
        if (*l == '\'') {
            printf("&quot;", *l);
        } else if (*l == '&')  {
            printf("&amp;", *l);
        } else if (*l == '<')  {
            printf("&lt;", *l);
        } else if (*l == '>')  {
            printf("&gt;", *l);
        } else {
            printf("%c", *l);
        }
        l++;
    }
}

void do_grid(const bool xml, const int width, const int height, const double maxwalkdist, const double walkspeed) {
    int x, y;
    if (width != height)
        err("width not equal to height");

    for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
            char *label;
            double t = mintime(width, (double)x, (double)y, maxwalkdist, walkspeed, &label);

            if (xml) {
                // print_escape_xml("hello you , & you too! < ha SÅ­edinenie");
                if (label) {
                    printf("<point x=\"%d\" y=\"%d\" time=\"%lf\" label=\"", x, y, t);
                    print_escape_xml(label);
                    printf("\" />\n");
                } else {
                    printf("<point x=\"%d\" y=\"%d\" time=\"%lf\" label=\"No route\" />\n", x, y, t, label);
                }
            } else {
                float singlet = (float)t;
                fwrite(&singlet, sizeof singlet, 1, stdout);
            }
        }
        if (xml)
            printf("\n");
    }
}

int main(int argc, char *argv[]) {
    double walkspeed, maxwalktime, maxwalkdist;
    int width, height;
    enum { m_query = 0, m_grid = 1, m_xmlgrid = 2 } mode = m_query;
    const unsigned numargs[7] = { 6, 4, 4 };
    FILE *fp;
    double query_e, query_n;

    // Testing individual functions
/*    
    double mapx, mapy;
    wgs84_to_map(1280, 52.516667, 13.416667, &mapx, &mapy); // Berlin
    printf("Berlin mapx, mapy: %lf %lf\n", mapx, mapy);
    wgs84_to_map(1280, 53.466667, -2.233333, &mapx, &mapy); // Manchester
    printf("Manchester mapx, mapy: %lf %lf\n", mapx, mapy); // 205.179267 602.814743
    wgs84_to_map(1280, 53.4, -2.983333, &mapx, &mapy); // Liverpool
    printf("Liverpool mapx, mapy: %lf %lf\n", mapx, mapy); //  188.112600 605.361160
    double lat, lon;
    map_to_wgs84(1280, 561.303711288889, 638.730705204974, &lat, &lon);
    printf("Berlin reverse: lat, lon: %lf %lf\n", lat, lon); // Berlin
    map_to_wgs84(1280, 736, 572, &lat, &lon);
    printf("Test reverse: lat, lon: %lf %lf\n", lat, lon);
    double dist = great_circle_distance(51.507778, -0.128056, 48.866667, 2.333056);
    printf("London to Paris: %lfm\n", dist);

    return 0;
    */

    fp = stdin;
    srand(time(NULL));

    if (argc < 2)
        die("first argument gives mode");

    if (0 == strcmp(argv[1], "query"))
        mode = m_query;
    else if (0 == strcmp(argv[1], "grid"))
        mode = m_grid;
    else if (0 == strcmp(argv[1], "xmlgrid"))
        mode = m_xmlgrid;
    else
        die("unknown mode '%s'", argv[1]);

    ++argv;
    --argc;

    if (argc - 1 != numargs[mode])
        die("need %d arguments", numargs[mode]);
 
    if (!parse_int(argv[1], &width))
        die("bad width '%s'", argv[1]);
    if (!parse_int(argv[2], &height))
        die("bad height '%s'", argv[2]);
    if (!parse_double(argv[3], &walkspeed))
        die("bad walk speed '%s'", argv[3]);
    if (!parse_double(argv[4], &maxwalktime))
        die("bad max walk time '%s'", argv[4]);
    if (mode == m_query) {
        if (!parse_double(argv[5], &query_e))
            die("bad query E '%s'", argv[5]);
        if (!parse_double(argv[6], &query_n))
            die("bad query N '%s'", argv[6]);
    }

    maxwalkdist = maxwalktime * walkspeed;
    
    pp = malloc((nppalloc = 16) * sizeof *pp);
    
    //fprintf(stderr, "lat\tlon\tdistance-to-pancras-km\ttime-in-hours\tcrow-speed-kmh\n");
    while (1) {
        // load in line, using fgets for safety
        char buf[1000];
        if (!fgets(buf, 1000, fp)) {
            break;
        }

        // parse it into the point structure
        char labelbuf[1000]; 
        if (sscanf(buf, "%lf %lf %lf %s\n", &pp[npp].N, &pp[npp].E, &pp[npp].time, &labelbuf) != 4) {
            break;
        }
        char *label = malloc((strlen(labelbuf) + 1) * sizeof(char));
        strcpy(label, labelbuf);
        pp[npp].label = label;

        double distance_to_st_pancras = great_circle_distance(51.53, -0.125, pp[npp].N, pp[npp].E) / 1000;
        double time_in_hours = pp[npp].time / 60 / 60;
        double crow_speed = distance_to_st_pancras / time_in_hours;
        // fprintf(stderr, "%f\t%f\t%lf\t%lfh\t%lf\t%s\n", pp[npp].N, pp[npp].E, distance_to_st_pancras, time_in_hours, crow_speed, label);

        if (crow_speed >= 160 || crow_speed <= 10) {
            fprintf(stderr, "ignored lat:%f lon:%f pancras:%lfkm time:%lfh crow:%lfkm/h\n", pp[npp].N, pp[npp].E, distance_to_st_pancras, time_in_hours, crow_speed);
        } else {
            ++npp;
            if (npp == nppalloc)
                pp = realloc(pp, (nppalloc *= 2) * sizeof *pp);
        }
    }

    debug("have %d points", npp);
    debug("max walk dist = %lf", maxwalkdist);

    qsort(pp, npp, sizeof *pp, point_sorter);

    if (mode == m_query) {
        if (width != height)
            err("width not equal to height");
        char *label;
        double t = mintime(width, query_e, query_n, maxwalkdist, walkspeed, &label);
        if (t == TIME_INFINITY) t = -1;
        printf("Result: %lf %lf %lf %s\n", query_e, query_n, t, label);
    } else if (mode == m_grid) {
        do_grid(0, width, height, maxwalkdist, walkspeed);
    } else if (mode == m_xmlgrid) {
        printf("<pointdetails>\n");
        do_grid(1, width, height, maxwalkdist, walkspeed);
        printf("</pointdetails>\n");
    } else {
        abort();
    }

    return 0;
}

