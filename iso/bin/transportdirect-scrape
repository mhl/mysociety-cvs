#!/usr/bin/perl -w
#
# transportdirect-scraper:
# Scrape Transport Direct.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

# Cardiff 20km CF101EP
#center = (318244, 175971)
#bounds = (308244 328244 165971 185971)
#
# 

# Cardiff 100km CF101EP
# center = (318244, 175971)
# bounds = (268244 368244 125971 225971)

#$to ||= 'CF101EP';
#$to ||= 'B152TT';
#$to ||= 'EH12QL';
#$to ||= 'SE58AZ';
#$to ||= 'SK84LA';

#$size ||= 100000;
#$size ||= 20000;


my $rcsid = ''; $rcsid .= '$Id: transportdirect-scrape,v 1.4 2007-11-30 12:48:07 francis Exp $';

use strict;
require 5.8.0;

use Cwd;
use DBI;
use HTML::TreeBuilder;
use IO::Handle;
use Text::CSV_XS;
use WWW::Mechanize;
use Time::HiRes;
use Getopt::Long;

use vars qw($to $size $htmldir $deadline $walkspeed $sqlite_database $date);
my $result = GetOptions ( 
                        "to=s" => \$to,
                        "size=i" => \$size,
                        "htmldir=s" => \$htmldir,
                        "deadline=s" => \$deadline,
                        "walkspeed=i" => \$walkspeed,
                        "db=s" => \$sqlite_database,
                        "date=s" => \$date,
                        );
if (!$sqlite_database || !$to || !$htmldir || !$date) {
    print <<END;

Screen scrapes Transport Direct to generate journey times to get to work at a
particular postcode.

Required parameters:
--db=filename.sqlite - database file containing stop info, and where journeys are saved (se below)
--to=POSTCODE - postcode of destination place of work, e.g. CB30FD
--htmldir=DIR - place to dump HTML files it had trouble with, for debugging
--date=DDMMYYYY - in near future, date to do the journeys on, you probably want to pick a weekday! e.g. 06022007

Optional parameters:
--size=METRES - destination is in a centre of a square of this size sides in metres, defaults to 20,000    
--deadline=HH:MM - hard time you have to get to work by, defaults to 09:00
--walkspeed=METRES/SEC - speed of walking to/from stops, in metres per second, defaults to 1 m/s

The database should have this schema. 
    CREATE TABLE journey (
        destination text not null references postcode(postcode),
        deadline text not null,
        origin text not null references postcode(postcode),
        starttime text not null,
        endtime text not null,
        primary key(destination, deadline, origin)
    );
    CREATE TABLE postcode ( postcode text not null primary key, easting integer not null, northing integer not null );
    CREATE TABLE stop2 ( name text not null, type text not null, easting integer not null, northing integer not null, postcode_closest text not null );
    CREATE INDEX jourey_destination_deadline_idx on journey(destination, deadline);
    CREATE INDEX postcode_easting_idx on postcode(easting);
    CREATE INDEX postcode_northing_idx on postcode(northing);
    CREATE INDEX stop2_easting_idx on stop2(easting);
    CREATE INDEX stop2_name_idx on stop2(name);
    CREATE INDEX stop2_northing_idx on stop2(northing);
    CREATE INDEX stop2_type_idx on stop2(type);

The postcode table should pre-contain the coordinates of every relevant
postcode (there are 1.7 million of them in the whole country). See
postcode-into-db for script to do this. Example row:
    AB101AF|394181|806429
The stop2 table should contain the coordinates of all relevant public transport
stops from NaPTAN. e.g. 
    Bus Station Bay 19|BCT|358942|173527|BS13LP

Postcodes are in uppercase with no spaces. Coordinates are an integer representation
of the 3 decimal plae OS national grid square references - i.e. are measured in
metres.0

The database does not record parameters like the date, or walkspeed in the
journey table, so if you vary them you should use a totally new database.

END
    exit;
}

$size ||= 20000;
$deadline ||= '09:00';
$walkspeed ||= 1;  # m/s

my $counter = 0;
sub dump_page ($) {
    my $m = shift;
    open(H, ">$htmldir/$counter.html");
    H->print($m->content());
    close(H);
    print STDERR $htmldir, "/$counter.html\n";
    ++$counter;
}

sub trim ($) {
    my $s = shift;
    $s =~ s/^\s+//s;
    $s =~ s/\s+$//s;
    return $s;
}

my $timere = qr/^([01][0-9]|2[0-3]):([0-5][0-9])$/;



sub time_add_minutes ($$) {
    my ($time, $mins) = @_;
    my ($H, $M) = ($time =~ $timere);
    die "invalid time '$time' in time_add_minutes" if (!defined($H));
    $M += $mins;
    while ($M > 59) {
        $M -= 60;
        ++$H;
    }
    while ($M < 0) {
        $M += 60;
        --$H;
    }
    return sprintf('%02d:%02d', $H, $M);
}

# time_diff_minutes A B
# Return A - B in minutes.
sub time_diff_minutes ($$) {
    my ($A, $B) = @_;
    my ($Ha, $Ma) = ($A =~ $timere);
    die "invalid time '$A' as first argument to time_diff_minutes"
        if (!defined($Ha));
    my ($Hb, $Mb) = ($B =~ $timere);
    die "invalid time '$B' as first argument to time_diff_minutes"
        if (!defined($Hb));
    
    return $Ma - $Mb + 60 * ($Ha - $Hb);
}

sub urlencode ($) {
    my $t = shift;
    $t =~ s/ /+/g;
    $t =~ s/([^A-Za-z0-9+])/sprintf('%%%02x', ord($1))/ge;
    return $t;
}

# get_latest_journey_before DEADLINE FROM TO
# Get the latest-starting journey which 
sub get_latest_journey_before_internal ($$$) {
    my ($deadline, $from, $to) = @_;

    my $nretries = 0;
tryagain:

    # this is documented in some transportdirect pdf somewhere
    my $params_starttime = $deadline;
    $params_starttime =~ s/://;
    my %params = (
            et => 'jp',
            id => 'http://www.mysociety.org/',
            oo => 'p',
            o => $from,
            do => 'p',
            d => $to,
            dt => $date,
            t => $params_starttime,
            da => 'a',
            c => 'false',
            p => 1
        );

    my $url = 'http://www.transportdirect.info/transportdirect/en/journeyplanning/jplandingpage.aspx?';
    foreach my $k (keys %params) {
        my $v = $params{$k};
        $url .= urlencode($k) . '=' . urlencode($v) . '&';
    }

    warn "getting URL $url...\n";

    our $m ||= new WWW::Mechanize();
    $m->agent_alias('Windows IE 6');
    $m->get($url);

    # now we get a dumb "please wait" page.
    my $delta = 1;
    my $total_delay = 0;
    while (my $link = $m->find_link(text => 'click this link.')) {
        print "usleep $delta\n";
        Time::HiRes::usleep($delta * 1000000);
        print "done\n";
        $total_delay += $delta;
#        dump_page($m);
    #    $m->follow_link(text => 'click on this link.');
        $m->submit_form(form_number => 1);
        $delta *= 2;
        $delta = 16 if ($delta > 16);

        print ".";
        if ($total_delay > 10) {
            warn "... no results after ${total_delay}s; retrying\n";
            if ($nretries > 3) {
                warn "    third retry, assuming there really are none\n";
                return ();
            }
            ++$nretries;
            goto tryagain;
        }
    }
    print "finished\n";

    print STDERR "---\n";
#    dump_page($m);

    my $html = HTML::TreeBuilder->new_from_content($m->content());

    # find "journey summary" table
    my $table = $html->look_down(_tag => 'table', id => 'jdetail');
    if (!$table) {
        warn "can't find 'Journey Summary' table => no results";
        if ($nretries <= 3) {
            ++$nretries;
            warn "    retrying...\n";
            goto tryagain;
        } else {
            warn "third retry, assuming there really are none\n";
            dump_page($m);
            return ();
        }
    }

    my $tbody = $table->look_down(_tag => 'tbody')
                    || die "can't find <tbody> in 'Journey Summary' table";

    # Extract all the rows.
    my @journeys = ( );
    my @rows = $tbody->look_down(_tag => 'tr');
    die "no journey rows in 'Journey Summary' table" unless (@rows);
    foreach (@rows) {
        my @cells = $_->look_down(_tag => 'td');
        die "journey row has " . scalar(@cells) . " cells (should be 6)"
            unless (@cells == 6);

        my ($modes, $changes, $start, $end, $duration) = map { trim($_->content()->[0]) } @cells[0 .. 4];

        # time with date
        if ($start =~ m#^..:.. \(../..\)$# || $end =~ m#^..:.. \(../..\)$#) {
            warn "  $start -> $end\n";
            next;
        }

        die "start time '$start' is not valid" if ($start !~ $timere);
        die "end time '$end' is not valid" if ($end !~ $timere);

        warn "  $start $end\n";

        push(@journeys, [$start, $end]);
    }
    return @journeys;
}

sub get_latest_journey_before ($$$) {
    my ($deadline, $from, $to) = @_;

    my @journeys = get_latest_journey_before_internal($deadline, $from, $to);

    return () if (!@journeys);

    return ($journeys[0]->[0], $journeys[0]->[1]);

#    return @journeys;
}

my $dbh = DBI->connect("dbi:SQLite:dbname=$sqlite_database", "", "", { AutoCommit => 0 });

my ($E, $N) = $dbh->selectrow_array('select easting, northing from postcode where postcode = ?', {}, $to);
die "no location for destination postcode '$to'" if (!defined($E));

# Bounds of rectangle.
my $WW = $E - $size / 2;
my $EE = $E + $size / 2;
my $SS = $N - $size / 2;
my $NN = $N + $size / 2;

warn "center = ($E, $N)\n";
warn "bounds = ($WW, $SS) to ($EE, $NN)\n";

#$WW = 500000;
#$EE = 600000;
#$SS = 200000;
#$NN = 300000;

my $Nalready = $dbh->selectrow_array('select count(*) from journey where destination = ? and deadline = ?', {}, $to, $deadline);

my $from;

# Find all the public transport stops within the region. For each one, find the
# postcode nearest to that stop, and find the journey time from that postcode
# to the destination.

my @stops = @{$dbh->selectall_arrayref("select easting, northing, name, postcode_closest from stop2 where easting > $WW - 500 and easting < $EE + 500 and northing > $SS - 500 and northing < $NN + 500 order by random()")};

warn "have $Nalready  / " . scalar(@stops) . " results so far\n";

foreach my $s (@stops) {
    my ($stopE, $stopN, $stopname, $pc) = @$s;

    # Find the nearest postcode.
    my ($E, $N) = $dbh->selectrow_array("select easting, northing from postcode where postcode = ?", {}, $pc);
    if (!defined($pc)) {
        warn "no postcode near $stopname\n";
        next;
    }

    my $dist = sqrt(($stopE - $E) ** 2 + ($stopN - $N) ** 2);
    printf STDERR "%s -> %s (%fm)\n", $stopname, $pc, $dist;

#my (@journeys) = get_latest_journey_before_internal($deadline, $pc, $to);
#print scalar(@journeys) . ",$dist\n";
#next;

    # Now see if we already have a reading for this postcode.
    my $time = $dbh->selectrow_array('select starttime from journey where journey.origin = ? and destination = ? and deadline = ?', {}, $pc, $to, $deadline);

    $dbh->commit();

    if (defined($time)) {
        if ($time) {
            warn "  already have start time $time\n";
            printf "%d %d %f\n", $stopE, $stopN, 60 * time_diff_minutes($deadline, $time) - ($dist / $walkspeed);
        } else {
            warn "  no journey possible\n";
        }
        next;
    }

    my ($start, $end) = get_latest_journey_before($deadline, $pc, $to);
 
    if (defined($start)) {
        warn "  start time is $start\n";
        printf "%d %d %f\n", $stopE, $stopN, time_diff_minutes($deadline, $start) - ($dist / $walkspeed) / 60;
        $dbh->do('insert into journey (destination, deadline, origin, starttime, endtime) values (?, ?, ?, ?, ?)', {}, $to, $deadline, $pc, $start, $end);
    } else {
        warn "  impossible to get there from here\n";
        $dbh->do('insert into journey (destination, deadline, origin, starttime, endtime) values (?, ?, ?, ?, ?)', {}, $to, $deadline, $pc, '', '');
    }
    $dbh->commit();
}

