#!/usr/bin/perl -I../perllib

use strict;
use warnings;

use LWP::Simple;
use JSON;
use DBI;
use HTML::Entities;
use Text::Unaccent;
use Data::Dumper;

use DBBahn;

$|=1;

# Size of grid cells, and number of cities to use in each.
my $cell_spacing = 10.0; # 1.0 # degrees lat/lon
my $cities_per_cell = 2;

# Threshold of maximum variation in grid cell of times from
# mean, remove any data where it is larger than that.
# XXX suspect this should be as low as 20% or even 10%
# 24% for Les Essarts / Les Essarts le Roi
my $threshold_variation_from_mean = 500.0; #24.0;
 
my $geonames_cities_url = 'http://ws.geonames.org/citiesJSON?north=%f&south=%f&east=%f&west=%f&maxRows=200';
my $geonames_get_url = 'http://ws.geonames.org/getJSON?geonameId=';

my ($sqlite_db) = @ARGV;
die "Parameter is sqlite database" if !$sqlite_db;
my $exists = -e $sqlite_db;
my $dbh = DBI->connect("dbi:SQLite:dbname=$sqlite_db", "", "", { AutoCommit => 0 });
if (!$exists) {
    $dbh->do(<<END);
    CREATE TABLE cache (
        url text not null,
        content text not null,
        primary key(url)
    );
END
    $dbh->commit();
}


print "geonameId\tfcode\tname\tpopulation\twikipedia\tlat\tlon\tduration\tactual_to\tswitched\n";

#my $lat = shift;
#my $lon = shift;
#for (my $s = $lat - 0.2; $s <= $lat + 0.2; $s += 0.1) {
#    for (my $w = $lon - 0.2; $w <= $lon + 0.2; $w += 0.1) {

sub consider_one_city($$) {
    my $city = shift;
    my $raw_name = shift;

    # Look up timings to travel there by train
    my $dur = $dbh->selectrow_array('select content from cache where cache.url = ?', {}, $raw_name);
    if (!$dur) {
        $dur = get_timings($raw_name);
        print "\n". Dumper($dur); exit;
        $dbh->do('insert into cache (url, content) values (?, ?)', {}, $raw_name, $dur);
        $dbh->commit();
        sleep 1;
    }

    my ($time, $actual_to, $switched_to) = split(/\t/, $dur);
    $city->{db_time} = $time;
    $city->{db_actual_to} = $actual_to;
    $city->{db_switched_to} = $switched_to;

    if ($time !~ m/^([0-9]+):([0-9]+)$/) {
        #warn "time $time not parsed";
        $city->{db_seconds} = undef;
    } else {
        $city->{db_seconds} = $1 * 60 * 60 + $2 * 60;
    }

    my $use = 1;
    # Name doesn't match exactly
    $use = 0 if (!$city->{db_actual_to});
    if ($use && $city->{db_actual_to} ne $city->{name}) {
        # Convert both names to same character set and encoding and
        # flatten accents and case.
        my $db_name = $city->{db_actual_to};
        $db_name = decode_entities($db_name);
        utf8::encode($db_name);
        $db_name = unac_string("utf-8", $db_name);
        $db_name = lc($db_name);

        # Find all alternative names
        my $alternateNames = $city->{names}->{alternateNames};
        my $geo_names = {};
        $geo_names->{$city->{name}} = 1;
        foreach my $nameref (@$alternateNames) {
            $geo_names->{$nameref->{name}} = 1 if length($nameref->{name}) > 2;
        }

        # See if we match any of them
        $use = 0; # reset it and look for new match afresh
        foreach my $geo_name (keys %$geo_names) {
            $geo_name = unac_string("utf-8", $geo_name);
            $geo_name = lc($geo_name);

            # Match exact ones, or ones where bahn.de returns with - after geonames name
            # (those are usually named stations within large cities, the city name
            # coming before the hyphen). Or ones with space why not.
            if ($db_name =~ m/^\Q$geo_name\E[-\s\(]/ || $db_name eq $geo_name) {
                print STDERR " name MATCH db:'$db_name' geo:'$geo_name'";
                $use = 1;
                last;
            } else {
                print STDERR " name mismatch db:'$db_name' geo:'$geo_name'";
            }
        }
    }
    $use = 0 if ($city->{population} <= 0); # Population not known by geonames
    $use = 0 if (!$city->{db_seconds}); # time didn't parse
    $city->{use} = $use;
    
}

# Original west: 27.0
# Moscow west: 37.598889 (37.6)
# Hopeful west: 45.0
for (my $s = 36.1; $s <= 70.7; $s += $cell_spacing) {
    for (my $w = -9.7; $w <= 27.0; $w += $cell_spacing) {

        # Work out bounds of a small grid cell
        my $n = $s + $cell_spacing;
        my $e = $w + $cell_spacing;
        print STDERR "W:$w E:$e S:$s N:$n...\n";
        my $urlF = sprintf($geonames_cities_url, $n, $s, $e, $w);
        print STDERR "geonames: $urlF\n";

        # Get list of cities from geonames in that grid cell
        my $cities = $dbh->selectrow_array('select content from cache where cache.url = ?', {}, $urlF);
        if (!$cities) {
            $cities = get($urlF);
            $dbh->do('insert into cache (url, content) values (?, ?)', {}, $urlF, $cities);
            $dbh->commit();
        }
        $cities = from_json($cities, { utf8 => 1 });
        if ($cities->{status}) {
            print STDERR $cities->{status}{message} . "\n";
            next;
        }

        # For each city, look up travel time to get there on bahn.de
        $cities = $cities->{geonames};
        @$cities = @$cities[0..$cities_per_cell-1];
        foreach (@$cities) {
            my $city = $_;

            my $raw_name = $city->{name};
            #print Dumper($city);
            utf8::encode($city->{name});
            print STDERR "geoid: $city->{geonameId} to bahn.de: $city->{name}";
        
            # Get list of alternative names
            my $urlG = $geonames_get_url . $city->{geonameId};
            $city->{names} = $dbh->selectrow_array('select content from cache where cache.url = ?', {}, $urlG);
            if (!$city->{names}) {
                $city->{names} = get($urlG);
                $dbh->do('insert into cache (url, content) values (?, ?)', {}, $urlG, $city->{names});
                $dbh->commit();
            }
            $city->{names} = from_json($city->{names}, { utf8 => 1 });

            # See whether to use city
            consider_one_city($city, $raw_name);

            if (!$city->{use}) {
                # Look for alternative name that is same language as spoken in country
                my $country = lc($city->{names}->{countryCode});
                my $alternateNames = $city->{names}->{alternateNames};
                #print Dumper($city->{names});
                foreach my $nameref (@$alternateNames) {
                    # XXX Hackily look for ones with same language code as country code (covers most cases for now)
                    if ($nameref->{lang} && $nameref->{lang} eq $country) {
                        my $name_utf8 = $nameref->{name};
                        utf8::encode($name_utf8);
                        if ($name_utf8 ne $city->{name}) {
                            $city->{name} = $name_utf8;
                            print STDERR " langname '$name_utf8'";
                        }
                        $raw_name = $nameref->{name};
                        last;
                    }
                }

                # See whether to use city
                consider_one_city($city, $raw_name);
            }

            if ($city->{use}) {
                print STDERR " $city->{db_time} $city->{db_seconds}s\n";
            } else {
                print STDERR " skip\n";
            }
        }

        # Decide which ones to use
        my $count;
        while (1) {
            # Find average time taken, and count of number of cities
            my $min_time = 1000000000;
            my $max_time = -1;
            my $sum_time = 0;
            $count = 0;
            foreach (@$cities) {
                my $city = $_;
                next if !$city->{use};

                $min_time = $city->{db_seconds} if $city->{db_seconds} < $min_time;
                $max_time = $city->{db_seconds} if $city->{db_seconds} > $max_time;
                $sum_time += $city->{db_seconds};
                $count++;
            }
            if ($count > 1) {
                my $avg_time = $sum_time / $count;
                my $percent_from_mean_1 = ($max_time - $avg_time) / $avg_time * 100;
                my $percent_from_mean_2 = ($avg_time - $min_time) / $avg_time * 100;
                my $max_precent_from_mean = $percent_from_mean_1 > $percent_from_mean_2 ? $percent_from_mean_1 : $percent_from_mean_2;
                print STDERR "cell time range min $min_time avg $avg_time max $max_time\n";

                # Find which city is most away from mean time
                my $worst_precent_from_mean = -1;
                my $worst_precent_from_mean_city = undef;
                foreach (@$cities) {
                    my $city = $_;
                    next if !$city->{use};

                    my $percent_from_mean = abs($city->{db_seconds} - $avg_time) / $avg_time * 100;
                    if ($percent_from_mean > $worst_precent_from_mean) {
                        $worst_precent_from_mean = $percent_from_mean;
                        $worst_precent_from_mean_city = $city;
                    }
                }

                print STDERR "variation " . ($max_time - $min_time) . " max_percent_from_mean $max_precent_from_mean\n";

                # Threshold of maximum variation in grid cell of times from
                # mean, remove any data where it is larger than that.
                if ($max_precent_from_mean > $threshold_variation_from_mean ) {
                    print STDERR "removing outlier " . $worst_precent_from_mean_city->{name} . "\n";
                    $worst_precent_from_mean_city->{use} = 0;
                    next;
                }
            }
            last;
        }

        # For grid cells with at least 2 points in (which must be within variance), print any cities left
        if ($count > 1) {
            foreach (@$cities) {
                my $city = $_;
               
                if ($city->{use}) {
                    # Print out
                    print "$city->{geonameId}\t$city->{fcode}\t$city->{name}\t$city->{population}\t$city->{wikipedia}\t$city->{lat}\t$city->{lng}\t$city->{db_seconds}\t$city->{db_actual_to}\n";
                }
            }
        } else {
            print STDERR "Rejected group $count\n";
        }

        print STDERR "\n";
    }
}
