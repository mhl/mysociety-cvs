#!/usr/bin/perl -I../perllib

use strict;
use warnings;

use LWP::Simple;
use JSON;
use DBI;
use HTML::Entities;
use Text::Unaccent;
use Data::Dumper;

use DBBahn;

$|=1;

my $spacing = 0.5;
my $maxgeonames = 10;
my $geonames_cities_url = 'http://ws.geonames.org/citiesJSON?north=%f&south=%f&east=%f&west=%f&maxRows=' . $maxgeonames;
my $geonames_get_url = 'http://ws.geonames.org/getJSON?geonameId=';

my ($sqlite_db) = @ARGV;
die "Parameter is sqlite database" if !$sqlite_db;
my $exists = -e $sqlite_db;
my $dbh = DBI->connect("dbi:SQLite:dbname=$sqlite_db", "", "", { AutoCommit => 0 });
if (!$exists) {
    $dbh->do(<<END);
    CREATE TABLE cache (
        url text not null,
        content text not null,
        primary key(url)
    );
END
    $dbh->commit();
}


print "geonameId\tfcode\tname\tpopulation\twikipedia\tlat\tlon\tduration\tactual_to\tswitched\n";

#my $lat = shift;
#my $lon = shift;
#for (my $s = $lat - 0.2; $s <= $lat + 0.2; $s += 0.1) {
#    for (my $w = $lon - 0.2; $w <= $lon + 0.2; $w += 0.1) {

for (my $s = 36.1; $s <= 70.7; $s += $spacing) {
    for (my $w = -9.7; $w <= 27.0; $w += $spacing) {

        # Work out bounds of a small grid cell
        my $n = $s + $spacing;
        my $e = $w + $spacing;
        print STDERR "W:$w E:$e S:$s N:$n...\n";
        my $urlF = sprintf($geonames_cities_url, $n, $s, $e, $w);
        print STDERR "geonames: $urlF\n";

        # Get list of cities from geonames in that grid cell
        my $cities = $dbh->selectrow_array('select content from cache where cache.url = ?', {}, $urlF);
        if (!$cities) {
            $cities = get($urlF);
            $dbh->do('insert into cache (url, content) values (?, ?)', {}, $urlF, $cities);
            $dbh->commit();
        }
        $cities = from_json($cities, { utf8 => 1 });
        if ($cities->{status}) {
            print STDERR $cities->{status}{message} . "\n";
            next;
        }

        # For each city, look up travel time to get there on bahn.de
        $cities = $cities->{geonames};
        foreach (@$cities) {
            my $city = $_;

            my $raw_name = $city->{name};
            utf8::encode($city->{name});
            print STDERR "geoid: $city->{geonameId} to bahn.de: $city->{name}";
        
            # Get alternative names
            my $urlG = $geonames_get_url . $city->{geonameId};
            my $names = $dbh->selectrow_array('select content from cache where cache.url = ?', {}, $urlG);
            if (!$names) {
                $names = get($urlG);
                $dbh->do('insert into cache (url, content) values (?, ?)', {}, $urlG, $names);
                $dbh->commit();
            }
            $names = from_json($names, { utf8 => 1 });
            # Look for alternative name that is same language as spoken in country
            my $country = lc($names->{countryCode});
            my $alternateNames = $names->{alternateNames};
            #print Dumper($names);
            foreach my $nameref (@$alternateNames) {
                # XXX Hackily look for ones with same language code as country code (covers most cases for now)
                if ($nameref->{lang} && $nameref->{lang} eq $country) {
                    my $name_utf8 = $nameref->{name};
                    utf8::encode($name_utf8);
                    if ($name_utf8 ne $city->{name}) {
                        $city->{name} = $name_utf8;
                        print STDERR " langname '$name_utf8'";
                    }
                    $raw_name = $nameref->{name};
                    last;
                }
            }

            # Look up timings to travel there by train
            my $dur = $dbh->selectrow_array('select content from cache where cache.url = ?', {}, $raw_name);
            if (!$dur) {
                $dur = get_timings($raw_name);
                $dbh->do('insert into cache (url, content) values (?, ?)', {}, $raw_name, $dur);
                $dbh->commit();
                sleep 1;
            }

            my ($time, $actual_to, $switched_to) = split(/\t/, $dur);
            $city->{db_time} = $time;
            $city->{db_actual_to} = $actual_to;
            $city->{db_switched_to} = $switched_to;

            if ($time !~ m/^([0-9]+):([0-9]+)$/) {
                #warn "time $time not parsed";
                $city->{db_seconds} = undef;
            } else {
                $city->{db_seconds} = $1 * 60 * 60 + $2 * 60;
            }

            my $use = 1;
            # Name doesn't match exactly
            $use = 0 if (!$city->{db_actual_to});
            if ($use && $city->{db_actual_to} ne $city->{name}) {
                # Convert both names to same character set and encoding and
                # flatten accents and case.
                my $db_name = $city->{db_actual_to};
                $db_name = decode_entities($db_name);
                utf8::encode($db_name);
                $db_name = unac_string("utf-8", $db_name);
                $db_name = lc($db_name);

                my $geo_name = $city->{name};
                $geo_name = unac_string("utf-8", $geo_name);
                $geo_name = lc($geo_name);

                # Match exact ones, or ones where bahn.de returns with - after geonames name
                # (those are usually named stations within large cities, the city name
                # coming before the hyphen). Or ones with space why not.
                if ($db_name =~ m/^\Q$geo_name\E[-\s]/ || $db_name eq $geo_name) {
                    print STDERR " name MATCH db:'$db_name' geo:'$geo_name'";
                } else {
                    $use = 0;
                    print STDERR " name mismatch db:'$db_name' geo:'$geo_name'";
                }
            }
            $use = 0 if ($city->{population} <= 0); # Population not known by geonames
            $use = 0 if (!$city->{db_seconds}); # time didn't parse
            $city->{use} = $use;
            
            if ($city->{use}) {
                print STDERR " $time $city->{db_seconds}s\n";
            } else {
                print STDERR " skip\n";
            }
         }

        # Decide which ones to use
        my $count;
        while (1) {
            # Find average time taken, and count of number of cities
            my $min_time = 1000000000;
            my $max_time = -1;
            my $sum_time = 0;
            $count = 0;
            foreach (@$cities) {
                my $city = $_;
                next if !$city->{use};

                $min_time = $city->{db_seconds} if $city->{db_seconds} < $min_time;
                $max_time = $city->{db_seconds} if $city->{db_seconds} > $max_time;
                $sum_time += $city->{db_seconds};
                $count++;
            }
            if ($count > 2) {
                my $avg_time = $sum_time / $count;
                my $percent_from_mean_1 = ($max_time - $avg_time) / $avg_time * 100;
                my $percent_from_mean_2 = ($avg_time - $min_time) / $avg_time * 100;
                my $max_precent_from_mean = $percent_from_mean_1 > $percent_from_mean_2 ? $percent_from_mean_1 : $percent_from_mean_2;
                print STDERR "cell time range min $min_time avg $avg_time max $max_time\n";

                # Find which city is most away from mean time
                my $worst_precent_from_mean = -1;
                my $worst_precent_from_mean_city = undef;
                foreach (@$cities) {
                    my $city = $_;
                    next if !$city->{use};

                    my $percent_from_mean = abs($city->{db_seconds} - $avg_time) / $avg_time * 100;
                    if ($percent_from_mean > $worst_precent_from_mean) {
                        $worst_precent_from_mean = $percent_from_mean;
                        $worst_precent_from_mean_city = $city;
                    }
                }

                print STDERR "variation " . ($max_time - $min_time) . " max_percent_from_mean $max_precent_from_mean\n";

                # Threshold of maximum variation in grid cell of times from
                # mean, remove any data where it is larger than that.
                # XXX suspect this should be as low as 20% or even 10%
                if ($max_precent_from_mean > 28.0) {
                    print STDERR "removing outlier " . $worst_precent_from_mean_city->{name} . "\n";
                    $worst_precent_from_mean_city->{use} = 0;
                    next;
                }
            }
            last;
        }

        # For grid cells with at least 3 points in, print any cities left
        if ($count > 2) {
            foreach (@$cities) {
                my $city = $_;
               
                if ($city->{use}) {
                    # Print out
                    print "$city->{geonameId}\t$city->{fcode}\t$city->{name}\t$city->{population}\t$city->{wikipedia}\t$city->{lat}\t$city->{lng}\t$city->{db_seconds}\t$city->{db_actual_to}\n";
                }
            }
        }

        print STDERR "\n";
    }
}
