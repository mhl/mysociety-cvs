#! /usr/bin/tcc -run -DLONGERBANDS -lgd -I/usr/local/ncarg/include/ncarg/ -lncarg -lngmath -L/usr/local/ncarg/lib/
/*
 * grid-to-ppm.c:
 * vim:syntax=c
 *
 * Convert grid file into a displayable image. Was originally traveltimemaps/cycle/map2.c
 *
 * Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
 * Email: chris@mysociety.org; WWW: http://www.mysociety.org/
 *
 */

static const char rcsid[] = "$Id: grid-to-ppm,v 1.8 2008-04-28 14:54:39 francis Exp $";

#include <assert.h>
#include <gd.h>
#include <math.h>
#include <pnm.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define err(...)    do { fprintf(stderr, "grid-to-ppm: "); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); } while (0)
#define die(...)    do { err(__VA_ARGS__); exit(1); } while (0)

#define debug(...)  err(__VA_ARGS__)

struct point {
    float E, N, time;
};

#define TIME_INFINITY       100000.

void time_to_colour(float y, uint8_t *r, uint8_t *g, uint8_t *b) {
    if (y == TIME_INFINITY)
        *r = *b = *g = 150;
    else {
        int i;
        float f;
        /* XXX histogram equalisation */
        struct {
            float y;
            uint8_t r, g, b;
        } palette[] = {
#ifndef MUNSELL
            /* this is GMT's rainbow spectrum */
                {   0.0,  170,   0,   0 },
                {   0.1,  246,   0,   0 },
                {   0.2,  255,  68,   0 },
                {   0.3,  255, 144,   0 },
                {   0.4,  255, 221,   0 },
                {   0.5,  255, 255,   0 },
                {   0.6,  189, 255,  12 },
                {   0.7,   63, 250,  54 },
                {   0.8,    0, 208, 139 },
                {   0.9,    0,  72, 250 },
                {   1.0,    0,   0, 205 },
                {     -1                }
#else
            /* Munsell */
                { 0.000000, 233,  59,  36 },
                { 0.052632, 234,  64,  38 },
                { 0.105263, 235,  97,  25 },
                { 0.157895, 247, 153,   0 },
                { 0.210526, 252, 202,   0 },
                { 0.263158, 255, 231,   0 },
                { 0.315789, 185, 198,   0 },
                { 0.368421,  83, 166,  57 },
                { 0.421053,  59, 149,  42 },
                { 0.473684,  35, 162,  56 },
                { 0.526316,  14, 151, 114 },
                { 0.578947,  22, 170, 129 },
                { 0.631579,  23, 158, 151 },
                { 0.684211,  58, 152, 205 },
                { 0.736842,  89, 113, 157 },
                { 0.789474,  86,  63, 127 },
                { 0.842105, 104,  68, 127 },
                { 0.894737, 169,  79, 122 },
                { 0.947368, 224,  61, 114 },
                { 1.000000, 216,  81, 113 },
                {       -1,               }
#endif /* MUNSELL */
            };

        for (i = 1; palette[i].y >= 0; ++i)
            if (palette[i].y > y)
                break;

        if (palette[i].y < 0) {
            *r = palette[i - 1].r;
            *g = palette[i - 1].g;
            *b = palette[i - 1].b;
        } else {
            f = (y - palette[i - 1].y) / (palette[i].y - palette[i - 1].y);
            *r = palette[i - 1].r + (palette[i].r - palette[i - 1].r) * f;
            *g = palette[i - 1].g + (palette[i].g - palette[i - 1].g) * f;
            *b = palette[i - 1].b + (palette[i].b - palette[i - 1].b) * f;
        }
    }
}

/* point_sorter A B
 * qsort(3) callback to compare eastings of A and B. */
int point_sorter(const void *a, const void *b) {
    const struct point *pa, *pb;
    pa = (const struct point*)a;
    pb = (const struct point*)b;
    if (pa->E < pb->E)
        return -1;
    else if (pa->E > pb->E)
        return +1;
    else
        return 0;
}

/* float_sorter A B
 * qsort(3) callback to sort floats. */
int float_sorter(const void *a, const void *b) {
    const float *fa, *fb;
    fa = (const float*)a;
    fb = (const float*)b;
    if (*fa < *fb)
        return -1;
    else if (*fa > *fb)
        return +1;
    else
        return 0;
}

/* Bounds of region. */
float west, east, south, north;

/* Pixel size of plot. */
int width, height;

/* Band sizes to use */
float bandsize; /* secs, try 600 */
int bandcount; /* try 200 */
int bandcolsep; /* try 1 */

/* traveltime E N
 * Return the minimum time for a journey from (E, N) to the destination, or
 * TIME_INFINITY if no journey is possible. */
static float *grid;
float traveltime(const float E, const float N) {
    int i, j;

    i = (E - west) / (east - west) * (width - 1);
    j = (north - N) / (north - south) * (height - 1);

    if (i < 0 || i >= width || j < 0 || j >= height)
        return TIME_INFINITY;
    else
        return grid[i + j * width];
}

int parse_float(const char *s, float *f) {
    return 1 == sscanf(s, "%f", f);
}

int parse_int(const char *s, int *i) {
    return 1 == sscanf(s, "%d", i);
}

float frand(void) {
    return rand() / (float)RAND_MAX;
}

#define NTIMEHIST       1000
float timehist[NTIMEHIST];

#ifndef NOHISTEQ
float histinvert(const float t) {
    int il = 0, ih = NTIMEHIST - 1;

    if (t == TIME_INFINITY)
        return t;
    
    if (t < timehist[il])
        return 0.;
    else if (t > timehist[ih])
        return 1.;
    
    while (ih > il + 1) {
        int i;
        i = (il + ih) / 2;
        if (timehist[i] < t)
            il = i;
        else if (timehist[i] > t)
            ih = i;
        else
            return i / (NTIMEHIST - 1.);
    }

    return (il + ih) / (2. * (NTIMEHIST - 1.));
}
#else
float histinvert(const float t) {
    int il = 50, ih = NTIMEHIST - 51;

    if (t == TIME_INFINITY)
        return t;

    if (t < 0)
        return 0.;
    else if (t > timehist[ih])
        return 1.;
    else
        return t / timehist[ih];
}
#endif  /* NOHISTEQ */

double fmax(const double a, const double b) {
    return a > b ? a : b;
}


void do_field(const int width, const int height, const float west, const float east, const float south, const float north) {
    int x, y;

    printf("P6\n%d %d\n255\n", width, height);

    for (y = 0; y < height; ++y) {
        float N;
        N = south + (north - south) * (height - y - 1) / (float)(height - 1);

        for (x = 0; x < width; ++x) {
            float E, t;
            uint8_t r, g, b;
            int band;
            E = west + (east - west) * x / (float)(width - 1);

            t = traveltime(E, N);
#ifdef LONGERBANDS
            r = 255; g = 255; b = 255;
            band = t / bandsize;
            if (band < 0) {
                r = 0; g = 0; b = 0;
            } else {
                if (band >= bandcount) {
                    band = bandcount;
                }
                g = 255 - band * bandcolsep;
                r = g;
                b = g;
            }
#else
    #ifdef BANDED
                if (t != TIME_INFINITY) t = 600. * (int)(t / 600.);   /* XXX rounding */
    #endif /* BANDED */
                time_to_colour(histinvert(t), &r, &g, &b);
#endif
            putc((int)r, stdout);
            putc((int)g, stdout);
            putc((int)b, stdout);
        }

        fprintf(stderr, "\r%d/%d", y + 1, height);
    }

    fprintf(stderr, "\n");

}

void do_grid(const bool plain, const int width, const int height, const float west, const float east, const float south, const float north) {
    int x, y;

    for (y = 0; y < height; ++y) {
        float N;
        N = south + (north - south) * (height - y - 1) / (float)(height - 1);

        for (x = 0; x < width; ++x) {
            float E, t;
            E = west + (east - west) * x / (float)(width - 1);
            t = traveltime(E, N);

            if (plain)
                printf("%f %f %f\n", E, N, t);
            else
                fwrite(&t, sizeof t, 1, stdout);
        }
        if (plain)
            printf("\n");
    }
}

int main(int argc, char *argv[]) {
    enum { m_field = 0 } mode = m_field;
    const unsigned numargs[4] = { 9 };
    
    srand(time(NULL));

    if (argc < 2)
        die("first argument gives mode");

    if (0 == strcmp(argv[1], "field"))
        mode = m_field;
    else
        die("unknown mode '%s'", argv[1]);

    ++argv;
    --argc;

    if (argc - 1 != numargs[mode])
        die("need %d arguments", numargs[mode]);
    
    if (!parse_float(argv[1], &west))
        die("bad west boundary '%s'", argv[1]);
    if (!parse_float(argv[2], &east))
        die("bad east boundary '%s'", argv[2]);
    if (!parse_float(argv[3], &south))
        die("bad south boundary '%s'", argv[3]);
    if (!parse_float(argv[4], &north))
        die("bad north boundary '%s'", argv[4]);
    if (!parse_int(argv[5], &width))
        die("bad width '%s'", argv[5]);
    if (!parse_int(argv[6], &height))
        die("bad height '%s'", argv[6]);
    if (!parse_float(argv[7], &bandsize))
        die("bad bandsize '%s'", argv[7]); /* secs */
    if (!parse_int(argv[8], &bandcount))
        die("bad count '%s'", argv[8]); 
    if (!parse_int(argv[9], &bandcolsep))
        die("bad colsep '%s'", argv[9]); 

    /* Read in the previously-computed grid of values. */
    grid = malloc(width * height * sizeof *grid);
    fread(grid, width, height * sizeof *grid, stdin);
    
    if (mode == m_field) {
        /* Histogram equalisation. We need to form the cumulative distribution
         * of travel times within the domain, so that we can allocate colours
         * to them equally. But since the function is slow to evaluate, do it
         * by sampling random points until we have enough possible journeys to
         * estimate the distribution. */
        int i;
        debug("sampling travel-time histogram");

        for (i = 0; i < NTIMEHIST; ++i) {
            float E, N;
            do {
                E = west + frand() * (east - west);
                N = south + frand() * (north - south);
            } while (TIME_INFINITY == (timehist[i] = traveltime(E, N)));
        }

        qsort(timehist, NTIMEHIST, sizeof *timehist, float_sorter);
    }

    if (mode == m_field)
        do_field(width, height, west, east, south, north);
    else
        abort();

    return 0;
}

